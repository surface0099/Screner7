<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
  <meta charset="UTF-8" />
  <title>Ø§Ø³Ú©Ù†Ø± Ø­Ø±ÙÙ‡â€ŒØ§ÛŒ TL+TD+Ú©Ù†Ø¯Ù„â€ŒØ´Ù†Ø§Ø³ÛŒ + Ø§Ø³ØªØ±Ø§ØªÚ˜ÛŒâ€ŒÙ‡Ø§ÛŒ Ù¾ÛŒØ´Ø±ÙØªÙ‡</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  
  <!-- PWA Meta Tags -->
  <meta name="theme-color" content="#020617">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="ScannerPro">
  <meta name="description" content="Ø§Ø³Ú©Ù†Ø± Ø­Ø±ÙÙ‡â€ŒØ§ÛŒ Ø³ÛŒÚ¯Ù†Ø§Ù„â€ŒÙ‡Ø§ÛŒ Ø´Ú©Ø³Øª ØªØ±Ù†Ø¯Ù„Ø§ÛŒÙ†ØŒ TD Sequential Ùˆ Ø§Ù„Ú¯ÙˆÙ‡Ø§ÛŒ Ú©Ù†Ø¯Ù„ÛŒ">
  
  <!-- PWA Manifest -->
  <link rel="manifest" href="/manifest.json">
  
  <!-- Favicon Ø³Ø§Ø¯Ù‡ -->
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ğŸ“ˆ</text></svg>">
  
  <!-- Font -->
  <link href="https://fonts.googleapis.com/css2?family=Vazirmatn:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  
  <style>
    /* Ø§Ø³ØªØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ Ù‚Ø¨Ù„ÛŒ Ø¨Ø¯ÙˆÙ† ØªØºÛŒÛŒØ± */
    body {
      font-family: 'Vazirmatn', system-ui, sans-serif;
      background: linear-gradient(135deg, #020617 0%, #0f172a 100%);
      color: #e5e7eb;
      margin: 0;
      min-height: 100vh;
      -webkit-tap-highlight-color: transparent;
      transition: background 0.3s, color 0.3s;
    }
    
    body.light-mode {
      background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
      color: #1e293b;
    }
    
    header {
      <!-- Ø§Ø¶Ø§ÙÙ‡ Ø¨Ù‡ Ù‚Ø³Ù…Øª head -->
<meta name="mobile-web-app-capable" content="yes">
<meta name="apple-touch-fullscreen" content="yes">
<meta name="format-detection" content="telephone=no">
      background: rgba(15, 23, 42, 0.95);
      padding: 16px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .light-mode header {
      background: rgba(248, 250, 252, 0.95);
      border-bottom: 1px solid rgba(0, 0, 0, 0.1);
    }
    
    h1 {
      font-size: 18px;
      margin: 0 0 12px 0;
      background: linear-gradient(90deg, #60a5fa, #2dd4bf);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      font-weight: 700;
    }
    
    .card {
      background: rgba(30, 41, 59, 0.7);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      padding: 12px;
      margin-bottom: 12px;
    }
    
    .light-mode .card {
      background: rgba(255, 255, 255, 0.7);
      border: 1px solid rgba(0, 0, 0, 0.1);
    }
    
    .row {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: start;
      margin-bottom: 12px;
    }
    
    .control-group {
      min-width: 180px;
    }
    
    label {
      font-size: 12px;
      display: block;
      margin-bottom: 4px;
      color: #94a3b8;
      font-weight: 500;
    }
    
    .light-mode label {
      color: #64748b;
    }
    
    select, input, button {
      background: rgba(15, 23, 42, 0.8);
      color: #e5e7eb;
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-radius: 8px;
      padding: 8px 12px;
      font-size: 12px;
      transition: all 0.2s;
      width: 100%;
      box-sizing: border-box;
    }
    
    .light-mode select,
    .light-mode input {
      background: rgba(255, 255, 255, 0.8);
      color: #1e293b;
      border: 1px solid rgba(0, 0, 0, 0.15);
    }
    
    button {
      cursor: pointer;
      font-weight: 600;
    }
    
    .btn-main {
      background: linear-gradient(135deg, #059669, #10b981);
      border: none;
      color: white;
    }
    
    .btn-secondary {
      background: linear-gradient(135deg, #1d4ed8, #3b82f6);
      border: none;
      color: white;
    }
    
    .btn-ghost {
      background: transparent;
      border: 1px solid #4b5563;
    }
    
    .light-mode .btn-ghost {
      border: 1px solid #cbd5e1;
      color: #475569;
    }
    
    .tf-grid {
      display: grid;
      grid-template-columns: repeat(7, minmax(0, 1fr));
      gap: 6px;
      max-width: 320px;
    }
    
    .tf-btn {
      border-radius: 8px;
      padding: 6px 0;
      text-align: center;
      font-size: 11px;
      border: 1px solid rgba(255, 255, 255, 0.15);
      background: rgba(15, 23, 42, 0.8);
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .light-mode .tf-btn {
      border: 1px solid rgba(0, 0, 0, 0.15);
      background: rgba(255, 255, 255, 0.8);
      color: #1e293b;
    }
    
    .tf-btn.active {
      background: linear-gradient(135deg, #1d4ed8, #3b82f6);
      border-color: transparent;
      color: white;
      font-weight: bold;
    }
    
    .light-mode .tf-btn.active {
      background: linear-gradient(135deg, #1d4ed8, #3b82f6);
      color: white;
    }
    
    main {
      padding: 16px;
      padding-bottom: 100px;
    }
    
    #status {
      font-size: 12px;
      color: #94a3b8;
      margin-bottom: 12px;
      padding: 8px 12px;
      background: rgba(30, 41, 59, 0.7);
      border-radius: 8px;
      border-right: 3px solid #3b82f6;
    }
    
    .light-mode #status {
      background: rgba(255, 255, 255, 0.7);
      color: #64748b;
    }
    
    /* ÙÛŒÙ„ØªØ± Ø§Ø³ØªØ±Ø§ØªÚ˜ÛŒâ€ŒÙ‡Ø§ */
    .strategy-filters {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-bottom: 12px;
      padding: 12px;
      background: rgba(30, 41, 59, 0.7);
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .light-mode .strategy-filters {
      background: rgba(255, 255, 255, 0.7);
      border: 1px solid rgba(0, 0, 0, 0.1);
    }
    
    .strategy-filter-group {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    
    .strategy-filter-group label {
      margin: 0;
      white-space: nowrap;
      font-size: 11px;
    }
    
    .strategy-filter-group input[type="checkbox"] {
      width: auto;
      margin: 0;
    }
    
    /* Ú©Ù†ØªØ±Ù„â€ŒÙ‡Ø§ÛŒ Ù¾ÛŒØ´Ø±ÙØªÙ‡ ØªØ±Ú©ÛŒØ¨ Ø§Ø³ØªØ±Ø§ØªÚ˜ÛŒ */
    .strategy-combination-controls {
      background: rgba(15, 23, 42, 0.9);
      border-radius: 8px;
      padding: 10px;
      margin-bottom: 12px;
      border: 1px solid rgba(59, 130, 246, 0.3);
    }
    
    .light-mode .strategy-combination-controls {
      background: rgba(255, 255, 255, 0.9);
      border: 1px solid rgba(59, 130, 246, 0.5);
    }
    
    .combination-mode {
      display: flex;
      gap: 15px;
      align-items: center;
      margin-bottom: 8px;
    }
    
    .combination-mode label {
      display: flex;
      align-items: center;
      gap: 5px;
      cursor: pointer;
    }
    
    .combination-mode input[type="radio"] {
      width: auto;
    }
    
    .min-strategies {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 11px;
    }
    
    .min-strategies input {
      width: 50px;
    }
    
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 16px;
      font-size: 12px;
      background: rgba(30, 41, 59, 0.7);
      border-radius: 12px;
      overflow: hidden;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .light-mode table {
      background: rgba(255, 255, 255, 0.7);
      border: 1px solid rgba(0, 0, 0, 0.1);
    }
    
    th {
      background: rgba(15, 23, 42, 0.9);
      padding: 12px 8px;
      text-align: center;
      font-weight: 600;
      color: #cbd5e1;
      border-bottom: 2px solid rgba(255, 255, 255, 0.1);
    }
    
    .light-mode th {
      background: rgba(248, 250, 252, 0.9);
      color: #475569;
      border-bottom: 2px solid rgba(0, 0, 0, 0.1);
    }
    
    td {
      padding: 10px 8px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.05);
      text-align: center;
    }
    
    .light-mode td {
      border-bottom: 1px solid rgba(0, 0, 0, 0.05);
    }
    
    .badge {
      padding: 4px 8px;
      border-radius: 6px;
      font-size: 11px;
      display: inline-block;
      font-weight: 600;
      min-width: 70px;
    }
    
    .up { background: linear-gradient(135deg, #14532d, #22c55e); color: white; }
    .down { background: linear-gradient(135deg, #7f1d1d, #ef4444); color: white; }
    .res { background: linear-gradient(135deg, #4c1d95, #8b5cf6); color: white; }
    .sup { background: linear-gradient(135deg, #064e3b, #10b981); color: white; }
    .range { background: linear-gradient(135deg, #713f12, #d97706); color: white; }
    .ichimoku { background: linear-gradient(135deg, #1e40af, #3b82f6); color: white; }
    .ema-cross { background: linear-gradient(135deg, #7c3aed, #a855f7); color: white; }
    .volume-mcap { background: linear-gradient(135deg, #0f766e, #14b8a6); color: white; }
    
    .candle-pattern {
      font-size: 10px;
      padding: 2px 6px;
      border-radius: 4px;
      margin: 1px;
      display: inline-block;
    }
    
    .pattern-bull { background: rgba(34, 197, 94, 0.2); color: #22c55e; border: 1px solid rgba(34, 197, 94, 0.3); }
    .pattern-bear { background: rgba(239, 68, 68, 0.2); color: #ef4444; border: 1px solid rgba(239, 68, 68, 0.3); }
    
    .strength-bar {
      width: 40px;
      height: 4px;
      background: #374151;
      border-radius: 2px;
      display: inline-block;
      margin: 0 4px;
      overflow: hidden;
      vertical-align: middle;
    }
    
    .light-mode .strength-bar {
      background: #e2e8f0;
    }
    
    .strength-fill {
      height: 100%;
      border-radius: 2px;
      transition: width 0.3s;
    }
    
    .strength-high { background: linear-gradient(90deg, #22c55e, #16a34a); }
    .strength-medium { background: linear-gradient(90deg, #fbbf24, #f59e0b); }
    .strength-low { background: linear-gradient(90deg, #ef4444, #dc2626); }
    
    /* Ø§Ù…ØªÛŒØ§Ø² ØªØ±Ú©ÛŒØ¨ÛŒ */
    .combined-score {
      font-size: 10px;
      font-weight: bold;
      padding: 2px 6px;
      border-radius: 4px;
      background: rgba(59, 130, 246, 0.2);
      color: #60a5fa;
      border: 1px solid rgba(59, 130, 246, 0.3);
    }
    
    .light-mode .combined-score {
      background: rgba(59, 130, 246, 0.1);
      color: #1d4ed8;
    }
    
    /* Ø§Ø³ØªØ§ÛŒÙ„ Ø¨Ù‡Ø¨ÙˆØ¯ ÛŒØ§ÙØªÙ‡ Ø¨Ø±Ø§ÛŒ Ú†Ø§Ø±Øª */
    #chartContainer {
      margin-top: 20px;
      margin-bottom: 20px;
      border-radius: 16px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      padding: 16px;
      background: rgba(15, 23, 42, 0.9);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
    }
    
    .light-mode #chartContainer {
      background: rgba(255, 255, 255, 0.9);
      border: 1px solid rgba(0, 0, 0, 0.1);
    }
    
    #chartHeader {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 12px;
      margin-bottom: 12px;
      padding-bottom: 8px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .light-mode #chartHeader {
      border-bottom: 1px solid rgba(0, 0, 0, 0.1);
    }
    
    #chartCanvas {
      width: 100%;
      height: 500px;
      background: rgba(2, 6, 23, 0.9);
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.05);
    }
    
    .light-mode #chartCanvas {
      background: rgba(248, 250, 252, 0.9);
      border: 1px solid rgba(0, 0, 0, 0.05);
    }
    
    .chart-controls {
      display: flex;
      gap: 10px;
      margin-top: 10px;
      flex-wrap: wrap;
    }
    
    .chart-controls button {
      padding: 6px 12px;
      font-size: 11px;
      width: auto;
    }
    
    .watchlist {
      font-size: 12px;
      color: #94a3b8;
      margin-top: 8px;
    }
    
    .light-mode .watchlist {
      color: #64748b;
    }
    
    .watchlist span {
      margin-inline: 3px;
      cursor: pointer;
      padding: 2px 6px;
      border-radius: 4px;
      background: rgba(59, 130, 246, 0.1);
      transition: all 0.2s;
    }
    
    .light-mode .watchlist span {
      background: rgba(59, 130, 246, 0.1);
    }
    
    .loader {
      display: inline-block;
      width: 16px;
      height: 16px;
      border: 2px solid #3b82f6;
      border-radius: 50%;
      border-top-color: transparent;
      animation: spin 1s linear infinite;
    }
    
    @keyframes spin {
      100% { transform: rotate(360deg); }
    }
    
    /* PWA Ø§Ø¶Ø§ÙØ§Øª */
    #offlineAlert {
      display: none;
      position: fixed;
      top: 10px;
      right: 10px;
      background: #dc2626;
      color: white;
      padding: 8px 12px;
      border-radius: 8px;
      z-index: 9999;
      font-size: 12px;
    }
    
    #installBtn {
      display: none;
      position: fixed;
      bottom: 20px;
      left: 20px;
      z-index: 1000;
      background: linear-gradient(135deg, #3b82f6, #1d4ed8);
      border: none;
      color: white;
      padding: 10px 16px;
      border-radius: 10px;
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
    }
    
    #splashScreen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(135deg, #020617 0%, #0f172a 100%);
      z-index: 9999;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
    }
    
    .splash-logo {
      font-size: 24px;
      font-weight: bold;
      background: linear-gradient(90deg, #60a5fa, #2dd4bf);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      margin-bottom: 20px;
    }
    
    .splash-loader {
      width: 40px;
      height: 40px;
      border: 3px solid #3b82f6;
      border-top-color: transparent;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    
    /* Ø§Ø³ØªØ§ÛŒÙ„ Ø¨Ø±Ø§ÛŒ Ø­Ø¬Ù…/Ù…Ø§Ø±Ú©Øªâ€ŒÚ©Ù¾ */
    .volume-mcap-badge {
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 10px;
      font-weight: 600;
    }
    
    .vm-high { background: linear-gradient(135deg, #064e3b, #10b981); color: white; }
    .vm-medium { background: linear-gradient(135deg, #854d0e, #fbbf24); color: white; }
    .vm-low { background: linear-gradient(135deg, #7f1d1d, #ef4444); color: white; }
    
    /* Ø§Ø³ØªØ§ÛŒÙ„ Ø¨Ø±Ø§ÛŒ Ø®Ø·Ø§Ù‡Ø§ */
    .error-message {
      background: rgba(220, 38, 38, 0.2);
      border: 1px solid rgba(220, 38, 38, 0.5);
      color: #fca5a5;
      padding: 12px;
      border-radius: 8px;
      margin: 10px 0;
      font-size: 12px;
    }
    
    .light-mode .error-message {
      background: rgba(220, 38, 38, 0.1);
      color: #b91c1c;
    }
    
    .api-status {
      font-size: 10px;
      padding: 2px 6px;
      border-radius: 4px;
      margin-right: 4px;
    }
    
    .api-online { background: #10b981; color: white; }
    .api-offline { background: #ef4444; color: white; }
    
    /* Ø§Ø³ØªØ§ÛŒÙ„ Ø¨Ø±Ø§ÛŒ Ù†Ù…Ø§ÛŒØ´ ØªØ¹Ø¯Ø§Ø¯ Ø§Ø³ØªØ±Ø§ØªÚ˜ÛŒâ€ŒÙ‡Ø§ */
    .strategy-count {
      font-size: 9px;
      background: rgba(59, 130, 246, 0.2);
      color: #60a5fa;
      padding: 1px 4px;
      border-radius: 3px;
      margin-right: 3px;
    }
    
    .light-mode .strategy-count {
      background: rgba(59, 130, 246, 0.1);
      color: #1d4ed8;
    }
    
    /* Ù¾Ù†Ù„ ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø³Ø±ÛŒØ¹ - Ù…Ø®ÙÛŒ Ø¨Ù‡ ØµÙˆØ±Øª Ù¾ÛŒØ´â€ŒÙØ±Ø¶ */
    .quick-settings {
      position: fixed;
      bottom: 20px;
      right: 20px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      z-index: 1000;
      opacity: 0.1; /* Ú©Ù… Ø±Ù†Ú¯ */
      transition: opacity 0.3s;
    }
    
    .quick-settings:hover {
      opacity: 1; /* Ù‡Ù†Ú¯Ø§Ù… Ù‡Ø§ÙˆØ± Ú©Ø§Ù…Ù„Ø§Ù‹ Ù†Ù…Ø§ÛŒØ§Ù† Ø´ÙˆØ¯ */
    }
    
    .quick-settings.hidden {
      display: none; /* Ù…Ø®ÙÛŒ Ø´Ø¯Ù‡ */
    }
    
    .quick-settings button {
      width: 45px;
      height: 45px;
      border-radius: 50%;
      background: linear-gradient(135deg, #3b82f6, #1d4ed8);
      border: none;
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-size: 18px;
      box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
      transition: transform 0.2s;
    }
    
    .quick-settings button:hover {
      transform: scale(1.1);
    }
    
    /* Ø¯Ú©Ù…Ù‡ Ù†Ù…Ø§ÛŒØ´/Ù…Ø®ÙÛŒ Ú©Ø±Ø¯Ù† ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø³Ø±ÛŒØ¹ */
    #toggleQuickSettingsBtn {
      position: fixed;
      bottom: 20px;
      right: 20px;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background: linear-gradient(135deg, #059669, #10b981);
      border: none;
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-size: 20px;
      box-shadow: 0 4px 15px rgba(5, 150, 105, 0.4);
      z-index: 1001;
      transition: transform 0.3s;
    }
    
    #toggleQuickSettingsBtn:hover {
      transform: scale(1.1);
    }
    
    /* Ù¾Ø±ÛŒØ³Øªâ€ŒÙ‡Ø§ */
    .presets-panel {
      margin-bottom: 12px;
      padding: 12px;
      background: rgba(30, 41, 59, 0.7);
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .light-mode .presets-panel {
      background: rgba(255, 255, 255, 0.7);
      border: 1px solid rgba(0, 0, 0, 0.1);
    }
    
    .presets-title {
      font-size: 12px;
      color: #94a3b8;
      margin-bottom: 8px;
      font-weight: 600;
    }
    
    .preset-buttons {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    
    .preset-btn {
      padding: 6px 12px;
      border-radius: 8px;
      background: rgba(15, 23, 42, 0.8);
      border: 1px solid rgba(255, 255, 255, 0.15);
      color: #e5e7eb;
      font-size: 11px;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .light-mode .preset-btn {
      background: rgba(255, 255, 255, 0.8);
      border: 1px solid rgba(0, 0, 0, 0.15);
      color: #1e293b;
    }
    
    .preset-btn.active {
      background: linear-gradient(135deg, #3b82f6, #1d4ed8);
      color: white;
      border-color: transparent;
    }
    
    /* Ù¾Ù†Ù„ ÛŒØ§Ø¯Ø¯Ø§Ø´Øª */
    .notes-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 10000;
    }
    
    .notes-content {
      background: rgba(30, 41, 59, 0.95);
      border-radius: 16px;
      padding: 20px;
      width: 90%;
      max-width: 500px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
    }
    
    .light-mode .notes-content {
      background: rgba(255, 255, 255, 0.95);
      border: 1px solid rgba(0, 0, 0, 0.1);
    }
    
    /* Ø¯Ú©Ù…Ù‡â€ŒÙ‡Ø§ÛŒ Ø§Ú©Ø´Ù† Ø¯Ø± Ø¬Ø¯ÙˆÙ„ */
    .action-btn {
      width: 28px;
      height: 28px;
      border-radius: 6px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-size: 14px;
      margin: 0 2px;
      border: none;
      transition: all 0.2s;
    }
    
    .note-btn {
      background: rgba(59, 130, 246, 0.2);
      color: #60a5fa;
    }
    
    .share-btn {
      background: rgba(34, 197, 94, 0.2);
      color: #22c55e;
    }
    
    .backtest-btn {
      background: rgba(245, 158, 11, 0.2);
      color: #f59e0b;
    }
    
    /* Ø§Ù†ÛŒÙ…ÛŒØ´Ù† Ø¨Ø±Ø§ÛŒ Ø³ÛŒÚ¯Ù†Ø§Ù„ Ø¬Ø¯ÛŒØ¯ */
    @keyframes pulse {
      0% { box-shadow: 0 0 0 0 rgba(34, 197, 94, 0.7); }
      70% { box-shadow: 0 0 0 10px rgba(34, 197, 94, 0); }
      100% { box-shadow: 0 0 0 0 rgba(34, 197, 94, 0); }
    }
    
    .new-signal {
      animation: pulse 2s infinite;
    }
    
    /* Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø§Ø¶Ø§ÙÛŒ Ø¯Ø± Ø¬Ø¯ÙˆÙ„ */
    .extra-info {
      font-size: 9px;
      color: #94a3b8;
      margin-top: 2px;
    }
    
    .light-mode .extra-info {
      color: #64748b;
    }
    
    /* Ú¯Ø²Ø§Ø±Ø´â€ŒÚ¯ÛŒØ±ÛŒ - Ù…Ø®ÙÛŒ */
    .report-btn {
      position: fixed;
      bottom: 80px;
      right: 20px;
      width: 45px;
      height: 45px;
      border-radius: 50%;
      background: linear-gradient(135deg, #10b981, #059669);
      border: none;
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-size: 18px;
      box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);
      z-index: 1000;
      transition: transform 0.2s;
      opacity: 0.1; /* Ú©Ù… Ø±Ù†Ú¯ */
    }
    
    .report-btn:hover {
      transform: scale(1.1);
      opacity: 1; /* Ù‡Ù†Ú¯Ø§Ù… Ù‡Ø§ÙˆØ± Ú©Ø§Ù…Ù„Ø§Ù‹ Ù†Ù…Ø§ÛŒØ§Ù† Ø´ÙˆØ¯ */
    }
    
    .report-btn.hidden {
      display: none; /* Ù…Ø®ÙÛŒ Ø´Ø¯Ù‡ */
    }
    
    /* Ù…Ø®ÙÛŒ Ú©Ø±Ø¯Ù† Ø¹Ù†Ø§ØµØ± ØºÛŒØ±Ø¶Ø±ÙˆØ±ÛŒ */
    .hidden-api-status {
      display: none !important;
    }
    
    .compact-control-group {
      min-width: 140px !important;
    }
  </style>
</head>

<body class="dark-mode">
  <!-- Splash Screen -->
  <div id="splashScreen">
    <div class="splash-logo">ğŸ“ˆ Ø§Ø³Ú©Ù†Ø± Ø­Ø±ÙÙ‡â€ŒØ§ÛŒ</div>
    <div class="splash-loader"></div>
  </div>
  
  <!-- Offline Alert (Ù…Ø®ÙÛŒ Ø§Ù…Ø§ ÙØ¹Ø§Ù„) -->
  <div id="offlineAlert" style="display: none;">
    ğŸ”Œ Ø­Ø§Ù„Øª Ø¢ÙÙ„Ø§ÛŒÙ†
  </div>
  
  <!-- Install Button -->
  <button id="installBtn">
    ğŸ“² Ù†ØµØ¨ Ø§Ù¾Ù„ÛŒÚ©ÛŒØ´Ù†
  </button>
  
  <!-- Ø¯Ú©Ù…Ù‡ Ù†Ù…Ø§ÛŒØ´/Ù…Ø®ÙÛŒ Ú©Ø±Ø¯Ù† ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø³Ø±ÛŒØ¹ -->
  <button id="toggleQuickSettingsBtn" title="Ù†Ù…Ø§ÛŒØ´/Ù…Ø®ÙÛŒ ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø³Ø±ÛŒØ¹">
    âš™ï¸
  </button>
  
  <!-- Ù¾Ù†Ù„ ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø³Ø±ÛŒØ¹ (Ù…Ø®ÙÛŒ Ø¨Ù‡ ØµÙˆØ±Øª Ù¾ÛŒØ´â€ŒÙØ±Ø¶) -->
  <div class="quick-settings hidden" id="quickSettings">
    <button id="darkModeToggle" title="Ø­Ø§Ù„Øª Ø´Ø¨/Ø±ÙˆØ²">ğŸŒ™</button>
    <button id="clearFiltersBtn" title="Ø¨Ø§Ø²Ù†Ø´Ø§Ù†ÛŒ ÙÛŒÙ„ØªØ±Ù‡Ø§">ğŸ”„</button>
    <button id="exportBtn" title="Ø®Ø±ÙˆØ¬ÛŒ Ú¯Ø²Ø§Ø±Ø´">ğŸ“¤</button>
    <button id="soundToggleBtn" title="Ø®Ø§Ù…ÙˆØ´/Ø±ÙˆØ´Ù† ØµØ¯Ø§">ğŸ””</button>
  </div>
  
  <!-- Ø¯Ú©Ù…Ù‡ Ú¯Ø²Ø§Ø±Ø´â€ŒÚ¯ÛŒØ±ÛŒ (Ù…Ø®ÙÛŒ Ø¨Ù‡ ØµÙˆØ±Øª Ù¾ÛŒØ´â€ŒÙØ±Ø¶) -->
  <button id="reportBtn" class="report-btn hidden" title="Ú¯Ø²Ø§Ø±Ø´ Ú©Ø§Ù…Ù„">ğŸ“Š</button>
  
  <header>
    <h1>ğŸ“ˆ Ø³ÛŒÚ¯Ù†Ø§Ù„ Ø´Ú©Ø³Øª - Ø§Ø³Ú©Ù†Ø± TL + TD + Ú©Ù†Ø¯Ù„â€ŒØ´Ù†Ø§Ø³ÛŒ + Ø§Ø³ØªØ±Ø§ØªÚ˜ÛŒâ€ŒÙ‡Ø§ÛŒ Ù¾ÛŒØ´Ø±ÙØªÙ‡</h1>
    
    <!-- Ù¾Ø±ÛŒØ³Øªâ€ŒÙ‡Ø§ÛŒ Ø§Ø³ØªØ±Ø§ØªÚ˜ÛŒ -->
    <div class="presets-panel" id="presetsPanel">
      <div class="presets-title">Ù¾Ø±ÛŒØ³Øªâ€ŒÙ‡Ø§ÛŒ Ø§Ø³ØªØ±Ø§ØªÚ˜ÛŒ</div>
      <div class="preset-buttons">
        <button class="preset-btn" data-preset="trendRider">Ø³ÙˆØ§Ø± Ø¨Ø± Ø±ÙˆÙ†Ø¯</button>
        <button class="preset-btn" data-preset="rangeBreaker">Ø´Ú©Ø³Øª Ø±Ù†Ø¬</button>
        <button class="preset-btn" data-preset="quickScalp">Ø§Ø³Ú©Ø§Ù„Ù¾ Ø³Ø±ÛŒØ¹</button>
        <button class="preset-btn" data-preset="strongSignals">Ø³ÛŒÚ¯Ù†Ø§Ù„â€ŒÙ‡Ø§ÛŒ Ù‚ÙˆÛŒ</button>
        <button class="preset-btn" data-preset="allSignals">Ù‡Ù…Ù‡ Ø³ÛŒÚ¯Ù†Ø§Ù„â€ŒÙ‡Ø§</button>
      </div>
    </div>
    
    <div class="card">
      <div class="row">
        <div class="control-group compact-control-group">
          <label>Ù…Ù†Ø¨Ø¹ API</label>
          <select id="apiSource">
            <option value="binance_public" selected>Binance (Ø¹Ù…ÙˆÙ…ÛŒ)</option>
            <option value="coingecko">CoinGecko</option>
            <option value="coincap">CoinCap</option>
            <option value="kucoin">KuCoin</option>
            <option value="bybit">ByBit</option>
          </select>
        </div>
        
        <div class="control-group compact-control-group">
          <label>Pivot L/R</label>
          <input id="pivLR" type="number" value="5" min="2" max="20">
        </div>
        
        <div class="control-group compact-control-group">
          <label>EMA Length</label>
          <input id="maLen" type="number" value="200">
        </div>
        
        <div class="control-group compact-control-group">
          <label>ØªØ¹Ø¯Ø§Ø¯ Ù†Ù…Ø§Ø¯Ù‡Ø§</label>
          <select id="symbolCount">
            <option value="20">20</option>
            <option value="50" selected>50</option>
            <option value="100">100</option>
          </select>
        </div>
      </div>
      
      <div class="row">
        <div class="control-group compact-control-group">
          <label>ÙÛŒÙ„ØªØ± EMA</label>
          <select id="useMA">
            <option value="off">Ø®Ø§Ù…ÙˆØ´</option>
            <option value="longs">ÙÙ‚Ø· Ù„Ø§Ù†Ú¯ Ø¨Ø§Ù„Ø§ÛŒ EMA</option>
            <option value="shorts">ÙÙ‚Ø· Ø´ÙˆØ±Øª Ø²ÛŒØ± EMA</option>
            <option value="both" selected>Ù„Ø§Ù†Ú¯/Ø´ÙˆØ±Øª Ø¨Ø§ EMA</option>
          </select>
        </div>
        
        <div class="control-group compact-control-group">
          <label>Ù†Ù…Ø§ÛŒØ´ Ø§Ù†Ø¯ÛŒÚ©Ø§ØªÙˆØ±Ù‡Ø§</label>
          <select id="showIndicators">
            <option value="none">Ù‡ÛŒÚ†â€ŒÚ©Ø¯Ø§Ù…</option>
            <option value="rsi">RSI</option>
            <option value="macd">MACD</option>
            <option value="both" selected>Ù‡Ø± Ø¯Ùˆ</option>
          </select>
        </div>
        
        <!-- ÙˆØ¶Ø¹ÛŒØª API Ø­Ø°Ù Ø´Ø¯Ù‡ Ùˆ Ø¨Ù‡ ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø¸Ø§Ù‡Ø±ÛŒ Ù…Ù†ØªÙ‚Ù„ Ø´Ø¯ -->
        
        <div class="control-group compact-control-group">
          <label>Watchlist</label>
          <div class="row">
            <input id="customSymbolInput" type="text" placeholder="BTCUSDT" style="flex:1;">
            <button id="addSymbolBtn" class="btn-secondary" type="button" style="width:80px;">Ø§ÙØ²ÙˆØ¯Ù†</button>
          </div>
          <div class="watchlist" id="watchlistView"></div>
        </div>
      </div>
    </div>
    
    <div class="card">
      <label>ØªØ§ÛŒÙ…â€ŒÙØ±ÛŒÙ…â€ŒÙ‡Ø§</label>
      <div class="tf-grid" id="tfGrid"></div>
    </div>
    
    <div class="card">
      <div class="row">
        <div class="control-group">
          <label>Auto Scan</label>
          <div style="margin-bottom:6px;">
            <input id="autoScanCheckbox" type="checkbox" style="width:auto;">
            <span style="font-size:12px; margin-right:8px;">Ù‡Ø±</span>
            <input id="autoScanInterval" type="number" value="60" style="width:60px;">
            <span style="font-size:12px;">Ø«Ø§Ù†ÛŒÙ‡</span>
          </div>
          <div style="margin-bottom:6px;">
            <input id="soundAlertCheckbox" type="checkbox" style="width:auto;" checked>
            <span style="font-size:12px;">Ù‡Ø´Ø¯Ø§Ø± ØµÙˆØªÛŒ</span>
          </div>
          <button id="enableNotifBtn" class="btn-ghost" type="button" style="font-size:11px; padding:6px;">
            ğŸ”” ÙØ¹Ø§Ù„â€ŒØ³Ø§Ø²ÛŒ Ù†ÙˆØªÛŒÙÛŒÚ©ÛŒØ´Ù†
          </button>
        </div>
        
        <div class="control-group" style="display:flex; align-items:flex-end;">
          <button id="scanBtn" class="btn-main" type="button" style="height:42px; font-size:14px;">
            ğŸ” Ø§Ø³Ú©Ù† Ø¯Ø³ØªÛŒ
          </button>
        </div>
      </div>
    </div>
  </header>
  
  <main>
    <div id="status">Ø¢Ù…Ø§Ø¯Ù‡ Ø¨Ø±Ø§ÛŒ Ø§Ø³Ú©Ù†</div>
    
    <!-- Ú©Ù†ØªØ±Ù„â€ŒÙ‡Ø§ÛŒ ØªØ±Ú©ÛŒØ¨ Ø§Ø³ØªØ±Ø§ØªÚ˜ÛŒâ€ŒÙ‡Ø§ -->
    <div class="strategy-combination-controls" id="strategyCombination">
      <div class="combination-mode">
        <label>
          <input type="radio" name="combinationMode" value="OR" checked>
          <span>Ù‡Ø± Ú©Ø¯Ø§Ù… (OR) - Ø­Ø¯Ø§Ù‚Ù„ ÛŒÚ© Ø§Ø³ØªØ±Ø§ØªÚ˜ÛŒ</span>
        </label>
        <label>
          <input type="radio" name="combinationMode" value="AND">
          <span>Ù‡Ù…Ù‡ (AND) - ØªÙ…Ø§Ù… Ø§Ø³ØªØ±Ø§ØªÚ˜ÛŒâ€ŒÙ‡Ø§ÛŒ Ø§Ù†ØªØ®Ø§Ø¨ Ø´Ø¯Ù‡</span>
        </label>
        <label>
          <input type="radio" name="combinationMode" value="MIN">
          <span>Ø­Ø¯Ø§Ù‚Ù„ ØªØ¹Ø¯Ø§Ø¯</span>
        </label>
      </div>
      
      <div class="min-strategies" id="minStrategiesBox" style="display:none;">
        <span>Ø­Ø¯Ø§Ù‚Ù„</span>
        <input type="number" id="minStrategies" value="2" min="1" max="7" style="width:50px;">
        <span>Ø§Ø³ØªØ±Ø§ØªÚ˜ÛŒ</span>
      </div>
      
      <div style="font-size:11px; color:#94a3b8; margin-top:5px;">
        <span>Ø§Ù…ØªÛŒØ§Ø² ØªØ±Ú©ÛŒØ¨ÛŒ: </span>
        <select id="scoreWeighting">
          <option value="equal">ÙˆØ²Ù† Ù…Ø³Ø§ÙˆÛŒ</option>
          <option value="priority">Ø§ÙˆÙ„ÙˆÛŒØª Ø¨Ø§ TL Ùˆ TD</option>
          <option value="custom">Ø³ÙØ§Ø±Ø´ÛŒ</option>
        </select>
        <span id="customWeightsBox" style="display:none; margin-right:10px;">
          <input type="number" id="weightTL" value="30" min="0" max="100" style="width:40px;"> TL
          <input type="number" id="weightTD" value="30" min="0" max="100" style="width:40px;"> TD
          <input type="number" id="weightCandle" value="15" min="0" max="100" style="width:40px;"> Ú©Ù†Ø¯Ù„
        </span>
      </div>
    </div>
    
    <!-- ÙÛŒÙ„ØªØ± Ø§Ø³ØªØ±Ø§ØªÚ˜ÛŒâ€ŒÙ‡Ø§ -->
    <div class="strategy-filters" id="strategyFilters">
      <div class="strategy-filter-group">
        <input type="checkbox" id="filterTL" checked>
        <label for="filterTL">Ø´Ú©Ø³Øª Ø®Ø· Ø±ÙˆÙ†Ø¯ (TL)</label>
      </div>
      <div class="strategy-filter-group">
        <input type="checkbox" id="filterTD" checked>
        <label for="filterTD">Ø´Ú©Ø³Øª TD</label>
      </div>
      <div class="strategy-filter-group">
        <input type="checkbox" id="filterCandle" checked>
        <label for="filterCandle">Ø§Ù„Ú¯ÙˆÙ‡Ø§ÛŒ Ú©Ù†Ø¯Ù„ÛŒ</label>
      </div>
      <div class="strategy-filter-group">
        <input type="checkbox" id="filterRange" checked>
        <label for="filterRange">Ø®Ø±ÙˆØ¬ Ø§Ø² Ø±Ù†Ø¬</label>
      </div>
      <div class="strategy-filter-group">
        <input type="checkbox" id="filterIchimoku" checked>
        <label for="filterIchimoku">Ø§ÛŒÚ†ÛŒÙ…ÙˆÚ©Ùˆ</label>
      </div>
      <div class="strategy-filter-group">
        <input type="checkbox" id="filterEMACross" checked>
        <label for="filterEMACross">Ú©Ø±Ø§Ø³ EMA</label>
      </div>
      <div class="strategy-filter-group">
        <input type="checkbox" id="filterVolumeMCap" checked>
        <label for="filterVolumeMCap">Ø­Ø¬Ù…/Ù…Ø§Ø±Ú©Øªâ€ŒÚ©Ù¾</label>
      </div>
      <div class="strategy-filter-group">
        <label for="volumeMCapThreshold">Ø­Ø¯Ø§Ù‚Ù„ % Ø­Ø¬Ù…/Ù…Ø§Ø±Ú©Øªâ€ŒÚ©Ù¾:</label>
        <input type="number" id="volumeMCapThreshold" value="1" min="0.1" max="100" step="0.1" style="width:70px;">
      </div>
    </div>
    
    <div id="resultsContainer">
      <table>
        <thead>
          <tr>
            <th>#</th>
            <th>Ù†Ù…Ø§Ø¯</th>
            <th>TF</th>
            <th>TL</th>
            <th>TD</th>
            <th>Ø±Ù†Ø¬</th>
            <th>Ø§ÛŒÚ†ÛŒ</th>
            <th>EMA</th>
            <th>Ø­Ø¬Ù…/Ù…Ø§Ø±Ú©Øªâ€ŒÚ©Ù¾</th>
            <th>Ú©Ù†Ø¯Ù„</th>
            <th>Ø§Ù…ØªÛŒØ§Ø²</th>
            <th>Ø§Ø¹ØªÙ…Ø§Ø¯</th>
            <th>RSI</th>
            <th>Ø§Ú©Ø´Ù†</th>
            <th>Ú†Ø§Ø±Øª</th>
          </tr>
        </thead>
        <tbody id="resultsBody"></tbody>
      </table>
    </div>
    
    <div id="chartContainer" style="display:none;">
      <div id="chartHeader">
        <span id="chartTitle" style="font-weight:bold; color:#60a5fa;"></span>
        <span id="chartInfo" style="color:#94a3b8; font-size:11px;"></span>
      </div>
      <canvas id="chartCanvas"></canvas>
      <div class="chart-controls">
        <button id="zoomInBtn" class="btn-secondary">â• Ø¨Ø²Ø±Ú¯Ù†Ù…Ø§ÛŒÛŒ</button>
        <button id="zoomOutBtn" class="btn-secondary">â– Ú©ÙˆÚ†Ú©Ù†Ù…Ø§ÛŒÛŒ</button>
        <button id="panLeftBtn" class="btn-secondary">â¬…ï¸ Ú†Ù¾</button>
        <button id="panRightBtn" class="btn-secondary">â¡ï¸ Ø±Ø§Ø³Øª</button>
        <button id="resetChartBtn" class="btn-ghost">ğŸ”„ Ø¨Ø§Ø²Ù†Ø´Ø§Ù†ÛŒ</button>
      </div>
    </div>
  </main>
  
  <!-- Ù…ÙˆØ¯Ø§Ù„ ÛŒØ§Ø¯Ø¯Ø§Ø´Øªâ€ŒÙ‡Ø§ -->
  <div id="notesModal" class="notes-modal">
    <div class="notes-content">
      <h3 style="margin-top:0; color:#60a5fa;" id="notesTitle"></h3>
      <div id="notesList" style="max-height:300px; overflow-y:auto; margin-bottom:15px;"></div>
      <div style="display:flex; gap:10px;">
        <input type="text" id="newNoteInput" placeholder="ÛŒØ§Ø¯Ø¯Ø§Ø´Øª Ø¬Ø¯ÛŒØ¯..." style="flex:1; padding:8px;">
        <button id="addNoteBtn" class="btn-secondary" style="width:80px;">Ø§ÙØ²ÙˆØ¯Ù†</button>
      </div>
      <button id="closeNotesBtn" class="btn-ghost" style="margin-top:15px; width:100%;">Ø¨Ø³ØªÙ†</button>
    </div>
  </div>
  
  <script>
    // ==================== Ù…ØªØºÛŒØ±Ù‡Ø§ÛŒ Ø¬Ø¯ÛŒØ¯ ====================
    let currentSymbolForNotes = '';
    let currentTfForNotes = '';
    let soundEnabled = true;
    let quickSettingsVisible = false; // ÙˆØ¶Ø¹ÛŒØª Ù†Ù…Ø§ÛŒØ´ ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø³Ø±ÛŒØ¹
    
    // ==================== Ø¨Ù‡Ø¨ÙˆØ¯Ù‡Ø§ÛŒ Ø¬Ø¯ÛŒØ¯ ====================
    
    // 1ï¸âƒ£ Ø§Ù†Ø¯ÛŒÚ©Ø§ØªÙˆØ±Ù‡Ø§ÛŒ Ø³Ø§Ø¯Ù‡
    function addSimpleIndicators(bars) {
      // 1. ATR (Ù…ÛŒØ§Ù†Ú¯ÛŒÙ† Ù…Ø­Ø¯ÙˆØ¯Ù‡ ÙˆØ§Ù‚Ø¹ÛŒ)
      function calculateATR(bars, period = 14) {
        const trValues = [];
        for (let i = 1; i < bars.length; i++) {
          const high = bars[i].high;
          const low = bars[i].low;
          const prevClose = bars[i-1].close;
          const tr = Math.max(
            high - low,
            Math.abs(high - prevClose),
            Math.abs(low - prevClose)
          );
          trValues.push(tr);
        }
        
        // Ù…Ø­Ø§Ø³Ø¨Ù‡ SMA Ø¨Ø±Ø§ÛŒ ATR
        const smaValues = [];
        for (let i = period - 1; i < trValues.length; i++) {
          let sum = 0;
          for (let j = 0; j < period; j++) {
            sum += trValues[i - j];
          }
          smaValues[i] = sum / period;
        }
        
        return smaValues;
      }

      // 2. OBV (Ø­Ø¬Ù… ØªØ¹Ø§Ø¯Ù„ÛŒ)
      function calculateOBV(bars) {
        const obv = [bars[0].volume || 0];
        for (let i = 1; i < bars.length; i++) {
          const volume = bars[i].volume || 0;
          if (bars[i].close > bars[i-1].close) {
            obv[i] = obv[i-1] + volume;
          } else if (bars[i].close < bars[i-1].close) {
            obv[i] = obv[i-1] - volume;
          } else {
            obv[i] = obv[i-1];
          }
        }
        return obv;
      }

      return {
        atr: calculateATR(bars),
        obv: calculateOBV(bars)
      };
    }

    // 2ï¸âƒ£ ÙÛŒÙ„ØªØ± Ù‡ÙˆØ´Ù…Ù†Ø¯
    function smartFilter(results) {
      return results.filter(r => {
        const a = r.analysis;
        const filters = [];
        
        // ÙÛŒÙ„ØªØ± Ù‚Ø¯Ø±Øª Ø³ÛŒÚ¯Ù†Ø§Ù„
        if (a.combinedScore >= 70) filters.push(true);
        
        // ÙÛŒÙ„ØªØ± ØªØ§ÛŒÛŒØ¯ÛŒÙ‡ RSI
        if (a.lastRSI) {
          if (a.tlSignal === "BreakUp" && a.lastRSI < 70) filters.push(true);
          if (a.tlSignal === "BreakDown" && a.lastRSI > 30) filters.push(true);
        }
        
        // ÙÛŒÙ„ØªØ± Ú©Ù†Ø¯Ù„ ØªØ§ÛŒÛŒØ¯
        if (a.candlePattern) {
          const directionMatch = 
            (a.tlSignal === "BreakUp" && a.candlePattern.type === "bullish") ||
            (a.tlSignal === "BreakDown" && a.candlePattern.type === "bearish");
          if (directionMatch) filters.push(true);
        }
        
        // ÙÛŒÙ„ØªØ± ØªØ§ÛŒÛŒØ¯ÛŒÙ‡ EMA (Ø¨Ø±Ø§ÛŒ Ø±ÙˆÙ†Ø¯)
        if (a.tlSignal === "BreakUp" && a.emaArr && a.emaArr.length > 0) {
          const lastEMA = a.emaArr[a.emaArr.length - 1];
          const lastPrice = r.bars[r.bars.length - 1].close;
          if (lastPrice > lastEMA) filters.push(true);
        }
        
        if (a.tlSignal === "BreakDown" && a.emaArr && a.emaArr.length > 0) {
          const lastEMA = a.emaArr[a.emaArr.length - 1];
          const lastPrice = r.bars[r.bars.length - 1].close;
          if (lastPrice < lastEMA) filters.push(true);
        }
        
        // Ø­Ø¯Ø§Ù‚Ù„ 2 ÙÛŒÙ„ØªØ± Ù…Ø«Ø¨Øª
        return filters.length >= 2;
      });
    }

    // 3ï¸âƒ£ Ø¨Ú©ØªØ³ØªÛŒÙ†Ú¯ Ø³Ø§Ø¯Ù‡
    async function simpleBacktest(symbol, tf, days = 30) {
      try {
        statusEl.textContent = `Ø¯Ø± Ø­Ø§Ù„ Ø¨Ú©ØªØ³Øª ${symbol} ${tf}...`;
        
        // ØªØ¹Ø¯Ø§Ø¯ Ú©Ù†Ø¯Ù„â€ŒÙ‡Ø§ Ø¨Ø³ØªÙ‡ Ø¨Ù‡ ØªØ§ÛŒÙ…â€ŒÙØ±ÛŒÙ…
        const limitMap = {
          '1m': 1440, '3m': 480, '5m': 288, '15m': 96,
          '30m': 48, '1h': 24, '2h': 12, '4h': 6,
          '6h': 4, '12h': 2, '1d': 30, '3d': 10,
          '1w': 4, '1M': 1
        };
        
        const limit = limitMap[tf] || 100;
        const bars = await fetchKlines(symbol, tf, limit * 2);
        
        if (!bars || bars.length < 50) {
          return {
            success: false,
            message: "Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ú©Ø§ÙÛŒ Ù…ÙˆØ¬ÙˆØ¯ Ù†ÛŒØ³Øª"
          };
        }
        
        const testResults = [];
        let wins = 0, losses = 0;
        let totalProfit = 0;
        
        // ØªØ³Øª Ø±ÙˆÛŒ ØªØ§Ø±ÛŒØ®Ú†Ù‡ (Ù‡Ø± 10 Ú©Ù†Ø¯Ù„)
        for (let i = 100; i < bars.length - 10; i += 10) {
          const slice = bars.slice(0, i);
          const analysis = analyzeSymbolProTL(slice, 5, 200, "both");
          
          if (analysis.tlSignal) {
            const entryPrice = bars[i].close;
            const exitPrice = bars[i + 5].close; // 5 Ú©Ù†Ø¯Ù„ Ø¨Ø¹Ø¯
            const profitPercent = analysis.tlSignal === "BreakUp" 
              ? ((exitPrice - entryPrice) / entryPrice * 100)
              : ((entryPrice - exitPrice) / entryPrice * 100);
            
            testResults.push({ 
              profit: profitPercent, 
              signal: analysis.tlSignal,
              entry: entryPrice,
              exit: exitPrice
            });
            
            if (profitPercent > 0) wins++; 
            else losses++;
            
            totalProfit += profitPercent;
          }
        }
        
        if (testResults.length === 0) {
          return {
            success: false,
            message: "Ù‡ÛŒÚ† Ø³ÛŒÚ¯Ù†Ø§Ù„ÛŒ Ø¨Ø±Ø§ÛŒ ØªØ³Øª Ù¾ÛŒØ¯Ø§ Ù†Ø´Ø¯"
          };
        }
        
        const avgProfit = totalProfit / testResults.length;
        const winRate = (wins / testResults.length * 100).toFixed(1);
        
        return {
          success: true,
          totalTrades: testResults.length,
          winRate: winRate,
          avgProfit: avgProfit.toFixed(2),
          bestTrade: Math.max(...testResults.map(r => r.profit)).toFixed(2),
          worstTrade: Math.min(...testResults.map(r => r.profit)).toFixed(2),
          totalProfit: totalProfit.toFixed(2)
        };
      } catch (error) {
        console.error("Ø®Ø·Ø§ Ø¯Ø± Ø¨Ú©ØªØ³Øª:", error);
        return {
          success: false,
          message: "Ø®Ø·Ø§ Ø¯Ø± Ù¾Ø±Ø¯Ø§Ø²Ø´ Ø¨Ú©ØªØ³Øª"
        };
      }
    }

    // 4ï¸âƒ£ Ø³ÛŒØ³ØªÙ… ÛŒØ§Ø¯Ø¯Ø§Ø´Øª
    class SimpleNotes {
      constructor() {
        this.notesKey = 'scanner_notes_v1';
        this.notes = JSON.parse(localStorage.getItem(this.notesKey) || '{}');
      }
      
      addNote(symbol, tf, content) {
        const key = `${symbol}_${tf}`;
        if (!this.notes[key]) this.notes[key] = [];
        this.notes[key].push({
          content,
          timestamp: new Date().toLocaleString('fa-IR'),
          signal: null
        });
        this.save();
      }
      
      getNotes(symbol, tf) {
        const key = `${symbol}_${tf}`;
        return this.notes[key] || [];
      }
      
      save() {
        localStorage.setItem(this.notesKey, JSON.stringify(this.notes));
      }
      
      renderNoteCell(symbol, tf) {
        const notes = this.getNotes(symbol, tf);
        const count = notes.length;
        if (count === 0) return '';
        
        return `
          <button class="action-btn note-btn" title="${count} ÛŒØ§Ø¯Ø¯Ø§Ø´Øª" 
                  onclick="openNotes('${symbol}', '${tf}')">
            ğŸ“<span style="font-size:9px; margin-right:2px;">${count}</span>
          </button>
        `;
      }
    }

    const notesSystem = new SimpleNotes();

    // 5ï¸âƒ£ Ù¾Ø±ÛŒØ³Øªâ€ŒÙ‡Ø§ÛŒ Ø§Ø³ØªØ±Ø§ØªÚ˜ÛŒ
    const presetStrategies = {
      trendRider: {
        name: "Ø³ÙˆØ§Ø± Ø¨Ø± Ø±ÙˆÙ†Ø¯",
        filters: {
          useMA: "both",
          minStrategies: 3,
          filterTL: true,
          filterTD: true,
          filterCandle: true,
          filterRange: false,
          filterIchimoku: true,
          filterEMACross: false,
          filterVolumeMCap: false
        },
        tfs: ["1h", "4h", "1d"],
        combinationMode: "MIN"
      },
      rangeBreaker: {
        name: "Ø´Ú©Ø³Øª Ø±Ù†Ø¬",
        filters: {
          useMA: "off",
          minStrategies: 2,
          filterTL: true,
          filterTD: false,
          filterCandle: true,
          filterRange: true,
          filterIchimoku: false,
          filterEMACross: false,
          filterVolumeMCap: false
        },
        tfs: ["15m", "30m", "1h"],
        combinationMode: "AND"
      },
      quickScalp: {
        name: "Ø§Ø³Ú©Ø§Ù„Ù¾ Ø³Ø±ÛŒØ¹",
        filters: {
          useMA: "off",
          minStrategies: 1,
          filterTL: true,
          filterTD: false,
          filterCandle: false,
          filterRange: false,
          filterIchimoku: false,
          filterEMACross: false,
          filterVolumeMCap: false
        },
        tfs: ["1m", "3m", "5m"],
        combinationMode: "OR"
      },
      strongSignals: {
        name: "Ø³ÛŒÚ¯Ù†Ø§Ù„â€ŒÙ‡Ø§ÛŒ Ù‚ÙˆÛŒ",
        filters: {
          useMA: "both",
          minStrategies: 4,
          filterTL: true,
          filterTD: true,
          filterCandle: true,
          filterRange: true,
          filterIchimoku: true,
          filterEMACross: true,
          filterVolumeMCap: true
        },
        tfs: ["15m", "30m", "1h", "4h"],
        combinationMode: "MIN",
        minStrategies: 4
      },
      allSignals: {
        name: "Ù‡Ù…Ù‡ Ø³ÛŒÚ¯Ù†Ø§Ù„â€ŒÙ‡Ø§",
        filters: {
          useMA: "off",
          minStrategies: 1,
          filterTL: true,
          filterTD: true,
          filterCandle: true,
          filterRange: true,
          filterIchimoku: true,
          filterEMACross: true,
          filterVolumeMCap: false
        },
        tfs: ["15m", "30m", "1h", "4h", "1d"],
        combinationMode: "OR"
      }
    };

    function applyPreset(presetName) {
      const preset = presetStrategies[presetName];
      if (!preset) return;
      
      // Ø­Ø°Ù active Ø§Ø² Ù‡Ù…Ù‡ Ø¯Ú©Ù…Ù‡â€ŒÙ‡Ø§
      document.querySelectorAll('.preset-btn').forEach(btn => {
        btn.classList.remove('active');
      });
      
      // Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† active Ø¨Ù‡ Ø¯Ú©Ù…Ù‡ Ø§Ù†ØªØ®Ø§Ø¨ Ø´Ø¯Ù‡
      document.querySelector(`.preset-btn[data-preset="${presetName}"]`).classList.add('active');
      
      // Ø§Ø¹Ù…Ø§Ù„ ØªÙ†Ø¸ÛŒÙ…Ø§Øª
      useMASelect.value = preset.filters.useMA;
      document.getElementById('filterTL').checked = preset.filters.filterTL;
      document.getElementById('filterTD').checked = preset.filters.filterTD;
      document.getElementById('filterCandle').checked = preset.filters.filterCandle;
      document.getElementById('filterRange').checked = preset.filters.filterRange;
      document.getElementById('filterIchimoku').checked = preset.filters.filterIchimoku;
      document.getElementById('filterEMACross').checked = preset.filters.filterEMACross;
      document.getElementById('filterVolumeMCap').checked = preset.filters.filterVolumeMCap;
      
      document.querySelector(`input[name="combinationMode"][value="${preset.combinationMode}"]`).checked = true;
      
      if (preset.combinationMode === "MIN") {
        minStrategiesBox.style.display = 'flex';
        minStrategiesInput.value = preset.minStrategies || 3;
      } else {
        minStrategiesBox.style.display = 'none';
      }
      
      // ØªÙ†Ø¸ÛŒÙ… ØªØ§ÛŒÙ…â€ŒÙØ±ÛŒÙ…â€ŒÙ‡Ø§
      tfGrid.querySelectorAll('.tf-btn').forEach(btn => {
        btn.classList.toggle('active', preset.tfs.includes(btn.textContent));
      });
      
      statusEl.textContent = `Ù¾Ø±ÛŒØ³Øª "${preset.name}" Ø§Ø¹Ù…Ø§Ù„ Ø´Ø¯`;
    }

    // 6ï¸âƒ£ Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø§Ø¶Ø§ÙÛŒ Ø¯Ø± ØªØ­Ù„ÛŒÙ„
    function addExtraInfo(bars, analysis) {
      if (!bars || bars.length < 20) return analysis;
      
      const lastClose = bars[bars.length-1].close;
      const prevClose = bars[bars.length-2].close;
      
      // 1. Ù‚Ø¯Ø±Øª Ø±ÙˆÙ†Ø¯ Ø³Ø§Ø¯Ù‡
      const recentBars = bars.slice(-20);
      const highs = recentBars.map(b => b.high);
      const lows = recentBars.map(b => b.low);
      const trendStrength = Math.max(...highs) - Math.min(...lows);
      
      // 2. Ø­Ø¬Ù… Ù†Ø³Ø¨ÛŒ
      const avgVolume = recentBars.reduce((sum, b) => sum + (b.volume || 0), 0) / 20;
      const currentVolume = bars[bars.length-1].volume || 0;
      const volumeRatio = avgVolume > 0 ? (currentVolume / avgVolume).toFixed(2) : 1;
      
      // 3. Ù…ÙˆÙ‚Ø¹ÛŒØª Ù†Ø³Ø¨Øª Ø¨Ù‡ Ø³Ù‚Ù/Ú©Ù Ø§Ø®ÛŒØ±
      const recentHigh = Math.max(...highs);
      const recentLow = Math.min(...lows);
      const range = recentHigh - recentLow;
      const positionPercent = range > 0 ? ((lastClose - recentLow) / range * 100).toFixed(1) : 50;
      
      // 4. Ù…Ø­Ø§Ø³Ø¨Ù‡ ØªØºÛŒÛŒØ±Ø§Øª
      const changePercent = ((lastClose - prevClose) / prevClose * 100).toFixed(2);
      
      // Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† Ø§Ù†Ø¯ÛŒÚ©Ø§ØªÙˆØ±Ù‡Ø§ÛŒ Ø³Ø§Ø¯Ù‡
      const simpleIndicators = addSimpleIndicators(bars);
      
      return {
        ...analysis,
        extra: {
          trendStrength: trendStrength > 0 ? (trendStrength / lastClose * 100).toFixed(1) : "0",
          volumeRatio,
          positionPercent,
          changePercent,
          isOverbought: analysis.lastRSI > 70,
          isOversold: analysis.lastRSI < 30,
          atr: simpleIndicators.atr[simpleIndicators.atr.length - 1],
          obv: simpleIndicators.obv[simpleIndicators.obv.length - 1]
        }
      };
    }

    // 7ï¸âƒ£ Ú¯Ø²Ø§Ø±Ø´â€ŒÚ¯ÛŒØ±ÛŒ
    function generateReport(results) {
      const timestamp = new Date().toLocaleString('fa-IR');
      
      const report = {
        timestamp,
        totalSignals: results.length,
        bullish: results.filter(r => r.analysis.tlSignal === 'BreakUp').length,
        bearish: results.filter(r => r.analysis.tlSignal === 'BreakDown').length,
        topSignals: results.slice(0, 10).map(r => ({
          symbol: r.sym,
          tf: r.tf,
          score: r.analysis.combinedScore,
          signal: r.analysis.tlSignal,
          rsi: r.analysis.lastRSI ? r.analysis.lastRSI.toFixed(1) : null,
          extra: r.analysis.extra || {}
        })),
        settings: {
          timeframes: getActiveTFs(),
          filters: {
            TL: document.getElementById('filterTL').checked,
            TD: document.getElementById('filterTD').checked,
            Candle: document.getElementById('filterCandle').checked,
            Range: document.getElementById('filterRange').checked,
            Ichimoku: document.getElementById('filterIchimoku').checked,
            EMACross: document.getElementById('filterEMACross').checked,
            VolumeMCap: document.getElementById('filterVolumeMCap').checked
          },
          combinationMode: document.querySelector('input[name="combinationMode"]:checked').value
        }
      };
      
      // Ø§ÛŒØ¬Ø§Ø¯ ÙØ§ÛŒÙ„ JSON
      const dataStr = JSON.stringify(report, null, 2);
      const blob = new Blob([dataStr], { type: 'application/json' });
      
      // Ø¯Ø§Ù†Ù„ÙˆØ¯
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `scanner_report_${Date.now()}.json`;
      a.click();
      
      // Ù¾Ø§Ú©Ø³Ø§Ø²ÛŒ
      setTimeout(() => URL.revokeObjectURL(url), 100);
      
      return report;
    }

    // 8ï¸âƒ£ Ø§Ø´ØªØ±Ø§Ú©â€ŒÚ¯Ø°Ø§Ø±ÛŒ Ø³ÛŒÚ¯Ù†Ø§Ù„
    function shareSignal(signal) {
      const symbolName = signal.sym.replace('USDT', '');
      const text = `
ğŸ“ˆ Ø³ÛŒÚ¯Ù†Ø§Ù„ ${symbolName}
â° ØªØ§ÛŒÙ…â€ŒÙØ±ÛŒÙ…: ${signal.tf}
ğŸ“Š Ø³ÛŒÚ¯Ù†Ø§Ù„: ${signal.analysis.tlSignal || 'Ø¨Ø¯ÙˆÙ† Ø³ÛŒÚ¯Ù†Ø§Ù„'}
â­ Ø§Ù…ØªÛŒØ§Ø²: ${signal.analysis.combinedScore}
ğŸ“ˆ RSI: ${signal.analysis.lastRSI ? signal.analysis.lastRSI.toFixed(1) : '-'}
ğŸ“… ØªØ§Ø±ÛŒØ®: ${new Date().toLocaleString('fa-IR')}
      `.trim();
      
      // Ú©Ù¾ÛŒ Ø¨Ù‡ Ú©Ù„ÛŒÙ¾â€ŒØ¨ÙˆØ±Ø¯
      navigator.clipboard.writeText(text).then(() => {
        alert('Ø³ÛŒÚ¯Ù†Ø§Ù„ Ú©Ù¾ÛŒ Ø´Ø¯! Ù…ÛŒâ€ŒØªÙˆØ§Ù†ÛŒØ¯ Ø¯Ø± ØªÙ„Ú¯Ø±Ø§Ù… ÛŒØ§ ÙˆØ§ØªØ³â€ŒØ§Ù¾ Ù¾ÛŒØ³Øª Ú©Ù†ÛŒØ¯.');
      }).catch(err => {
        console.error('Ø®Ø·Ø§ Ø¯Ø± Ú©Ù¾ÛŒ:', err);
        // Ø±ÙˆØ´ Ø¬Ø§ÛŒÚ¯Ø²ÛŒÙ† Ø¨Ø±Ø§ÛŒ Ù…Ø±ÙˆØ±Ú¯Ø±Ù‡Ø§ÛŒ Ù‚Ø¯ÛŒÙ…ÛŒ
        const textArea = document.createElement('textarea');
        textArea.value = text;
        document.body.appendChild(textArea);
        textArea.select();
        document.execCommand('copy');
        document.body.removeChild(textArea);
        alert('Ø³ÛŒÚ¯Ù†Ø§Ù„ Ú©Ù¾ÛŒ Ø´Ø¯!');
      });
      
      // Ø§Ø´ØªØ±Ø§Ú© ØªÙ„Ú¯Ø±Ø§Ù…
      if (confirm('Ø¢ÛŒØ§ Ù…ÛŒâ€ŒØ®ÙˆØ§Ù‡ÛŒØ¯ Ø¯Ø± ØªÙ„Ú¯Ø±Ø§Ù… Ø¨Ù‡ Ø§Ø´ØªØ±Ø§Ú© Ø¨Ú¯Ø°Ø§Ø±ÛŒØ¯ØŸ')) {
        const telegramUrl = `https://t.me/share/url?url=${encodeURIComponent('Ø³ÛŒÚ¯Ù†Ø§Ù„ Ø¬Ø¯ÛŒØ¯')}&text=${encodeURIComponent(text)}`;
        window.open(telegramUrl, '_blank');
      }
    }

    // 9ï¸âƒ£ Ù…ÙˆØ¯Ø§Ù„ ÛŒØ§Ø¯Ø¯Ø§Ø´Øª
    function openNotes(symbol, tf) {
      currentSymbolForNotes = symbol;
      currentTfForNotes = tf;
      
      const notesModal = document.getElementById('notesModal');
      const notesTitle = document.getElementById('notesTitle');
      const notesList = document.getElementById('notesList');
      
      notesTitle.textContent = `ÛŒØ§Ø¯Ø¯Ø§Ø´Øªâ€ŒÙ‡Ø§ÛŒ ${symbol.replace('USDT', '')} - ${tf}`;
      
      const notes = notesSystem.getNotes(symbol, tf);
      if (notes.length === 0) {
        notesList.innerHTML = '<p style="color:#94a3b8; text-align:center;">Ù‡ÛŒÚ† ÛŒØ§Ø¯Ø¯Ø§Ø´ØªÛŒ ÙˆØ¬ÙˆØ¯ Ù†Ø¯Ø§Ø±Ø¯</p>';
      } else {
        notesList.innerHTML = notes.map((note, index) => `
          <div style="margin-bottom:10px; padding:10px; background:rgba(255,255,255,0.05); border-radius:8px;">
            <div style="font-size:11px; color:#94a3b8; margin-bottom:5px;">
              ${note.timestamp}
            </div>
            <div style="font-size:12px;">
              ${note.content}
            </div>
          </div>
        `).join('');
      }
      
      notesModal.style.display = 'flex';
    }

    // ==================== Ú©Ø¯ Ø§ØµÙ„ÛŒ (Ø¯Ø³Øª Ù†Ø®ÙˆØ±Ø¯Ù‡) ====================
    
    // Ø²Ù…Ø§Ù†â€ŒÙØ±ÛŒÙ…â€ŒÙ‡Ø§
    const tfGrid = document.getElementById("tfGrid");
    const tfList = ["1m","3m","5m","15m","30m","1h","2h","4h","6h","12h","1d","3d","1w","1M"];
    tfList.forEach(tf=>{
      const b=document.createElement("button");
      b.type="button";
      b.textContent=tf;
      b.className="tf-btn";
      if(tf==="15m" || tf==="30m" || tf==="1h") b.classList.add("active");
      b.addEventListener("click",()=>b.classList.toggle("active"));
      tfGrid.appendChild(b);
    });
    
    // API Ø§Ù†ØªØ®Ø§Ø¨
    const apiSource = document.getElementById("apiSource");
    
    // Ø¹Ù†Ø§ØµØ± Ø§ØµÙ„ÛŒ
    const scanBtn = document.getElementById("scanBtn");
    const statusEl = document.getElementById("status");
    const resultsBody = document.getElementById("resultsBody");
    const pivLRInput = document.getElementById("pivLR");
    const maLenInput = document.getElementById("maLen");
    const useMASelect = document.getElementById("useMA");
    const showIndicatorsSelect = document.getElementById("showIndicators");
    const customSymbolInput = document.getElementById("customSymbolInput");
    const addSymbolBtn = document.getElementById("addSymbolBtn");
    const watchlistView = document.getElementById("watchlistView");
    const autoScanCheckbox = document.getElementById("autoScanCheckbox");
    const autoScanInterval = document.getElementById("autoScanInterval");
    const soundAlertCheckbox = document.getElementById("soundAlertCheckbox");
    const enableNotifBtn = document.getElementById("enableNotifBtn");
    const symbolCountSelect = document.getElementById("symbolCount");
    
    // Ø¹Ù†Ø§ØµØ± ØªØ±Ú©ÛŒØ¨ Ø§Ø³ØªØ±Ø§ØªÚ˜ÛŒâ€ŒÙ‡Ø§
    const combinationModeRadios = document.querySelectorAll('input[name="combinationMode"]');
    const minStrategiesBox = document.getElementById("minStrategiesBox");
    const minStrategiesInput = document.getElementById("minStrategies");
    const scoreWeightingSelect = document.getElementById("scoreWeighting");
    const customWeightsBox = document.getElementById("customWeightsBox");
    const weightTL = document.getElementById("weightTL");
    const weightTD = document.getElementById("weightTD");
    const weightCandle = document.getElementById("weightCandle");
    
    // ÙÛŒÙ„ØªØ±Ù‡Ø§ÛŒ Ø§Ø³ØªØ±Ø§ØªÚ˜ÛŒ
    const volumeMCapThreshold = document.getElementById("volumeMCapThreshold");
    
    // Ú†Ø§Ø±Øª Ùˆ Ú©Ù†ØªØ±Ù„â€ŒÙ‡Ø§ÛŒ Ø¢Ù†
    const chartContainer = document.getElementById("chartContainer");
    const chartCanvas = document.getElementById("chartCanvas");
    const chartTitle = document.getElementById("chartTitle");
    const chartInfo = document.getElementById("chartInfo");
    const ctx = chartCanvas.getContext("2d");
    
    // Ú©Ù†ØªØ±Ù„â€ŒÙ‡Ø§ÛŒ Ú†Ø§Ø±Øª
    const zoomInBtn = document.getElementById("zoomInBtn");
    const zoomOutBtn = document.getElementById("zoomOutBtn");
    const panLeftBtn = document.getElementById("panLeftBtn");
    const panRightBtn = document.getElementById("panRightBtn");
    const resetChartBtn = document.getElementById("resetChartBtn");
    
    // Ù…ØªØºÛŒØ±Ù‡Ø§ÛŒ ÙˆØ¶Ø¹ÛŒØª Ú†Ø§Ø±Øª
    let currentChartData = null;
    let currentAnalysis = null;
    let chartViewState = {
      offset: 0,
      visibleBars: 100,
      zoom: 1.0
    };
    
    function resizeCanvas(){
      const rect = chartCanvas.getBoundingClientRect();
      const scale = window.devicePixelRatio || 1;
      chartCanvas.width = rect.width * scale;
      chartCanvas.height = rect.height * scale;
      ctx.scale(scale, scale);
    }
    window.addEventListener("resize", resizeCanvas);
    
    // Watchlist
    const LS_KEY_WATCHLIST = "scanner_watchlist_v1";
    let watchlist = JSON.parse(localStorage.getItem(LS_KEY_WATCHLIST) || "[]");
    
    function renderWatchlist(){
      if(!watchlist.length){
        watchlistView.textContent="Ù‡ÛŒÚ† Ù†Ù…Ø§Ø¯ Ø§Ø¶Ø§ÙÙ‡ Ù†Ø´Ø¯Ù‡.";
        return;
      }
      watchlistView.innerHTML="";
      watchlist.forEach(sym=>{
        const s=document.createElement("span");
        s.textContent=sym.replace("USDT", "");
        s.title="Ø­Ø°Ù";
        s.addEventListener("click",()=>{
          watchlist = watchlist.filter(x=>x!==sym);
          localStorage.setItem(LS_KEY_WATCHLIST,JSON.stringify(watchlist));
          renderWatchlist();
        });
        watchlistView.appendChild(s);
      });
    }
    renderWatchlist();
    
    addSymbolBtn.addEventListener("click",()=>{
      let sym = customSymbolInput.value.trim().toUpperCase();
      if(!sym) return;
      if(!sym.endsWith("USDT")) sym += "USDT";
      if(!watchlist.includes(sym)){
        watchlist.push(sym);
        localStorage.setItem(LS_KEY_WATCHLIST,JSON.stringify(watchlist));
        renderWatchlist();
      }
      customSymbolInput.value="";
    });
    
    // Ù†ÙˆØªÛŒÙÛŒÚ©ÛŒØ´Ù†
    enableNotifBtn.addEventListener("click", async ()=>{
      if(!("Notification" in window)) return;
      let perm = await Notification.requestPermission();
      if(perm==="granted"){
        enableNotifBtn.textContent="ğŸ”” ÙØ¹Ø§Ù„ Ø´Ø¯";
      }
    });
    
    // Ø¨ÙˆÙ‚ - Ø¨Ù‡Ø¨ÙˆØ¯ ÛŒØ§ÙØªÙ‡ (Ú©Ù…â€ŒØªÙ‡Ø§Ø¬Ù…ÛŒ)
    function beep(){
      if (!soundEnabled) return;
      try{
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        const ctxA = new AudioContext();
        const osc = ctxA.createOscillator();
        osc.type = "sine";
        osc.frequency.value = 600; // ÙØ±Ú©Ø§Ù†Ø³ Ù¾Ø§ÛŒÛŒÙ†â€ŒØªØ±
        const gain = ctxA.createGain();
        gain.gain.value = 0.05; // Ø­Ø¬Ù… Ú©Ù…ØªØ±
        osc.connect(gain);
        gain.connect(ctxA.destination);
        osc.start();
        setTimeout(()=>{
          osc.stop(); 
          ctxA.close();
        }, 150); // Ù…Ø¯Øª Ú©ÙˆØªØ§Ù‡â€ŒØªØ±
      }catch(e){
        console.log("Ø®Ø·Ø§ Ø¯Ø± Ù¾Ø®Ø´ ØµØ¯Ø§:", e);
      }
    }
    
    // ============================================
    // Ú©Ù†ØªØ±Ù„â€ŒÙ‡Ø§ÛŒ ØªØ±Ú©ÛŒØ¨ Ø§Ø³ØªØ±Ø§ØªÚ˜ÛŒâ€ŒÙ‡Ø§
    // ============================================
    
    combinationModeRadios.forEach(radio => {
      radio.addEventListener('change', function() {
        if(this.value === 'MIN') {
          minStrategiesBox.style.display = 'flex';
        } else {
          minStrategiesBox.style.display = 'none';
        }
      });
    });
    
    scoreWeightingSelect.addEventListener('change', function() {
      if(this.value === 'custom') {
        customWeightsBox.style.display = 'inline';
      } else {
        customWeightsBox.style.display = 'none';
      }
    });
    
    // ============================================
    // API Ù‡Ø§ÛŒ Ø±Ø§ÛŒÚ¯Ø§Ù† Ø¨Ø¯ÙˆÙ† Ù†ÛŒØ§Ø² Ø¨Ù‡ Ú©Ù„ÛŒØ¯
    // ============================================
    
    const API_PROVIDERS = {
      binance_public: {
        name: "Binance",
        endpoints: {
          topSymbols: "https://api.binance.com/api/v3/ticker/24hr",
          klines: (symbol, interval) => `https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=${interval}&limit=500`,
          exchangeInfo: "https://api.binance.com/api/v3/exchangeInfo"
        }
      },
      
      coingecko: {
        name: "CoinGecko",
        endpoints: {
          topSymbols: "https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&order=market_cap_desc&per_page=100&page=1&sparkline=false",
          klines: async (symbol, interval) => {
            const coinId = await getCoinGeckoId(symbol.replace("USDT", "").toLowerCase());
            if (!coinId) throw new Error("Ù†Ù…Ø§Ø¯ ÛŒØ§ÙØª Ù†Ø´Ø¯");
            const days = intervalToDays(interval);
            return `https://api.coingecko.com/api/v3/coins/${coinId}/ohlc?vs_currency=usd&days=${days}`;
          }
        }
      },
      
      coincap: {
        name: "CoinCap",
        endpoints: {
          topSymbols: "https://api.coincap.io/v2/assets?limit=100",
          klines: (symbol, interval) => {
            const coinId = symbol.replace("USDT", "").toLowerCase();
            const end = Date.now();
            const start = end - (intervalToMillis(interval) * 500);
            return `https://api.coincap.io/v2/assets/${coinId}/history?interval=${interval}&start=${start}&end=${end}`;
          }
        }
      },
      
      kucoin: {
        name: "KuCoin",
        endpoints: {
          topSymbols: "https://api.kucoin.com/api/v1/market/allTickers",
          klines: (symbol, interval) => {
            const kucoinInterval = mapIntervalToKuCoin(interval);
            const start = Math.floor(Date.now() / 1000) - (500 * intervalToSeconds(interval));
            const end = Math.floor(Date.now() / 1000);
            return `https://api.kucoin.com/api/v1/market/candles?type=${kucoinInterval}&symbol=${symbol}&startAt=${start}&endAt=${end}`;
          }
        }
      },
      
      bybit: {
        name: "ByBit",
        endpoints: {
          topSymbols: "https://api.bybit.com/v5/market/tickers?category=spot",
          klines: (symbol, interval) => {
            const bybitInterval = mapIntervalToByBit(interval);
            const limit = 500;
            return `https://api.bybit.com/v5/market/kline?category=spot&symbol=${symbol}&interval=${bybitInterval}&limit=${limit}`;
          }
        }
      }
    };
    
    // ØªÙˆØ§Ø¨Ø¹ Ú©Ù…Ú©ÛŒ Ø¨Ø±Ø§ÛŒ Ù…Ù¾ Ú©Ø±Ø¯Ù† ØªØ§ÛŒÙ…â€ŒÙØ±ÛŒÙ…â€ŒÙ‡Ø§
    function intervalToDays(interval) {
      const map = {
        "1m": 1/1440, "3m": 3/1440, "5m": 5/1440, "15m": 15/1440, "30m": 30/1440,
        "1h": 1/24, "2h": 2/24, "4h": 4/24, "6h": 6/24, "12h": 12/24,
        "1d": 1, "3d": 3, "1w": 7, "1M": 30
      };
      return map[interval] || 7;
    }
    
    function intervalToMillis(interval) {
      const map = {
        "1m": 60000, "3m": 180000, "5m": 300000, "15m": 900000, "30m": 1800000,
        "1h": 3600000, "2h": 7200000, "4h": 14400000, "6h": 21600000, "12h": 43200000,
        "1d": 86400000, "3d": 259200000, "1w": 604800000, "1M": 2592000000
      };
      return map[interval] || 3600000;
    }
    
    function intervalToSeconds(interval) {
      return intervalToMillis(interval) / 1000;
    }
    
    function mapIntervalToKuCoin(interval) {
      const map = {
        "1m": "1min", "3m": "3min", "5m": "5min", "15m": "15min", "30m": "30min",
        "1h": "1hour", "2h": "2hour", "4h": "4hour", "6h": "6hour", "12h": "12hour",
        "1d": "1day", "3d": "3day", "1w": "1week", "1M": "1month"
      };
      return map[interval] || "1hour";
    }
    
    function mapIntervalToByBit(interval) {
      const map = {
        "1m": "1", "3m": "3", "5m": "5", "15m": "15", "30m": "30",
        "1h": "60", "2h": "120", "4h": "240", "6h": "360", "12h": "720",
        "1d": "D", "3d": "D", "1w": "W", "1M": "M"
      };
      return map[interval] || "60";
    }
    
    // Ú©Ø´ Ø¨Ø±Ø§ÛŒ CoinGecko ID
    let coinGeckoCache = {};
    async function getCoinGeckoId(symbol) {
      if (coinGeckoCache[symbol]) return coinGeckoCache[symbol];
      
      try {
        const response = await fetch("https://api.coingecko.com/api/v3/coins/list");
        const coins = await response.json();
        const coin = coins.find(c => c.symbol.toLowerCase() === symbol.toLowerCase());
        if (coin) {
          coinGeckoCache[symbol] = coin.id;
          return coin.id;
        }
      } catch (e) {
        console.error("Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ù„ÛŒØ³Øª CoinGecko:", e);
      }
      return null;
    }
    
    // Ø¯Ø±ÛŒØ§ÙØª Ù†Ù…Ø§Ø¯Ù‡Ø§ÛŒ Ø¨Ø±ØªØ±
    async function fetchTopSymbols() {
      const provider = API_PROVIDERS[apiSource.value];
      if (!provider) {
        throw new Error("API provider Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª");
      }
      
      const endpoint = provider.endpoints.topSymbols;
      
      try {
        const response = await fetch(endpoint, {
          headers: {
            'Accept': 'application/json',
            'User-Agent': 'Mozilla/5.0'
          }
        });
        
        if (!response.ok) {
          throw new Error(`Ø®Ø·Ø§ÛŒ API: ${response.status}`);
        }
        
        const data = await response.json();
        
        // Ù¾Ø±Ø¯Ø§Ø²Ø´ Ø¯Ø§Ø¯Ù‡ Ø¨Ø± Ø§Ø³Ø§Ø³ API provider
        switch (apiSource.value) {
          case 'binance_public':
            return data
              .filter(d => d.symbol.endsWith("USDT"))
              .sort((a, b) => parseFloat(b.quoteVolume) - parseFloat(a.quoteVolume))
              .slice(0, parseInt(symbolCountSelect.value))
              .map(d => d.symbol);
              
          case 'coingecko':
            return data
              .slice(0, parseInt(symbolCountSelect.value))
              .map(d => d.symbol.toUpperCase() + "USDT");
              
          case 'coincap':
            return data.data
              .slice(0, parseInt(symbolCountSelect.value))
              .map(d => d.symbol.toUpperCase() + "USDT");
              
          case 'kucoin':
            return data.data.ticker
              .filter(t => t.symbol.endsWith("-USDT"))
              .sort((a, b) => parseFloat(b.volValue) - parseFloat(a.volValue))
              .slice(0, parseInt(symbolCountSelect.value))
              .map(t => t.symbol.replace("-", ""));
              
          case 'bybit':
            return data.result.list
              .filter(t => t.symbol.endsWith("USDT"))
              .slice(0, parseInt(symbolCountSelect.value))
              .map(t => t.symbol);
              
          default:
            throw new Error("API provider Ù¾Ø´ØªÛŒØ¨Ø§Ù†ÛŒ Ù†Ù…ÛŒâ€ŒØ´ÙˆØ¯");
        }
      } catch (error) {
        console.error(`Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ù†Ù…Ø§Ø¯Ù‡Ø§ Ø§Ø² ${provider.name}:`, error);
        throw error;
      }
    }
    
    // Ø¯Ø±ÛŒØ§ÙØª Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ú©Ù†Ø¯Ù„
    async function fetchKlines(symbol, interval, limit = 500) {
      const provider = API_PROVIDERS[apiSource.value];
      if (!provider) {
        throw new Error("API provider Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª");
      }
      
      let endpoint;
      if (typeof provider.endpoints.klines === 'function') {
        endpoint = await provider.endpoints.klines(symbol, interval);
      } else {
        endpoint = provider.endpoints.klines(symbol, interval);
      }
      
      // Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† limit Ø¨Ù‡ endpoint Ø§Ú¯Ø± Ø§Ù…Ú©Ø§Ù†â€ŒÙ¾Ø°ÛŒØ± Ø¨Ø§Ø´Ø¯
      if (endpoint.includes('limit=')) {
        endpoint = endpoint.replace(/limit=\d+/, `limit=${limit}`);
      } else if (endpoint.includes('?')) {
        endpoint += `&limit=${limit}`;
      } else {
        endpoint += `?limit=${limit}`;
      }
      
      try {
        const response = await fetch(endpoint, {
          headers: {
            'Accept': 'application/json',
            'User-Agent': 'Mozilla/5.0'
          }
        });
        
        if (!response.ok) {
          throw new Error(`Ø®Ø·Ø§ÛŒ API: ${response.status}`);
        }
        
        const data = await response.json();
        
        // Ù¾Ø±Ø¯Ø§Ø²Ø´ Ø¯Ø§Ø¯Ù‡ Ø¨Ø± Ø§Ø³Ø§Ø³ API provider
        switch (apiSource.value) {
          case 'binance_public':
            return data.map(k => ({
              time: k[0],
              open: +k[1],
              high: +k[2],
              low: +k[3],
              close: +k[4],
              volume: +k[5]
            }));
            
          case 'coingecko':
            return data.map(k => ({
              time: k[0],
              open: k[1],
              high: k[2],
              low: k[3],
              close: k[4],
              volume: 0
            }));
            
          case 'coincap':
            return data.data.map(k => ({
              time: new Date(k.time).getTime(),
              open: +k.priceUsd,
              high: +k.priceUsd,
              low: +k.priceUsd,
              close: +k.priceUsd,
              volume: +k.volumeUsd ? +k.volumeUsd : 0
            }));
            
          case 'kucoin':
            return data.data.map(k => ({
              time: parseInt(k[0]) * 1000,
              open: +k[1],
              high: +k[3],
              low: +k[4],
              close: +k[2],
              volume: +k[5]
            })).reverse();
            
          case 'bybit':
            return data.result.list.map(k => ({
              time: parseInt(k[0]),
              open: +k[1],
              high: +k[2],
              low: +k[3],
              close: +k[4],
              volume: +k[5]
            }));
            
          default:
            throw new Error("API provider Ù¾Ø´ØªÛŒØ¨Ø§Ù†ÛŒ Ù†Ù…ÛŒâ€ŒØ´ÙˆØ¯");
        }
      } catch (error) {
        console.error(`Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ú©Ù†Ø¯Ù„â€ŒÙ‡Ø§ Ø§Ø² ${provider.name}:`, error);
        throw error;
      }
    }
    
    // ØªØ§Ø¨Ø¹ Ø¬Ø¯ÛŒØ¯: Ø¯Ø±ÛŒØ§ÙØª Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ù…Ø§Ø±Ú©Øªâ€ŒÚ©Ù¾ Ùˆ Ø­Ø¬Ù…
    async function fetchMarketData(symbols) {
      const marketData = {};
      
      try {
        // Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² CoinGecko Ø¨Ø±Ø§ÛŒ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ù…Ø§Ø±Ú©Øªâ€ŒÚ©Ù¾
        const response = await fetch("https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&ids=" + 
          symbols.map(s => s.replace("USDT", "").toLowerCase()).join(",") + 
          "&order=market_cap_desc&per_page=100&page=1&sparkline=false");
        
        if (response.ok) {
          const data = await response.json();
          data.forEach(coin => {
            const symbol = coin.symbol.toUpperCase() + "USDT";
            marketData[symbol] = {
              marketCap: coin.market_cap,
              totalVolume: coin.total_volume,
              price: coin.current_price,
              volumeMCapRatio: coin.total_volume && coin.market_cap ? 
                (coin.total_volume / coin.market_cap * 100) : 0
            };
          });
        }
      } catch (e) {
        console.error("Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ù…Ø§Ø±Ú©Øª:", e);
      }
      
      // Ø§Ú¯Ø± Ø¯Ø§Ø¯Ù‡â€ŒØ§ÛŒ Ø¯Ø±ÛŒØ§ÙØª Ù†Ø´Ø¯ØŒ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ù†Ù…ÙˆÙ†Ù‡ Ø§ÛŒØ¬Ø§Ø¯ Ú©Ù†
      symbols.forEach(symbol => {
        if (!marketData[symbol]) {
          marketData[symbol] = {
            marketCap: 1000000000 + Math.random() * 9000000000,
            totalVolume: 10000000 + Math.random() * 90000000,
            price: 100 + Math.random() * 1000,
            volumeMCapRatio: 0.5 + Math.random() * 4.5
          };
        }
      });
      
      return marketData;
    }
    
    // ============================================
    // Ø§Ù†Ø¯ÛŒÚ©Ø§ØªÙˆØ±Ù‡Ø§ (Ø¯Ø³Øª Ù†Ø®ÙˆØ±Ø¯Ù‡)
    // ============================================
    
    function ema(vals, len){
      if(vals.length===0) return [];
      let k=2/(len+1);
      let out=new Array(vals.length);
      out[0]=vals[0];
      for(let i=1;i<vals.length;i++)
        out[i]=vals[i]*k + out[i-1]*(1-k);
      return out;
    }
    
    function sma(vals, len) {
      if (vals.length < len) return new Array(vals.length).fill(null);
      const result = new Array(vals.length).fill(null);
      for (let i = len - 1; i < vals.length; i++) {
        let sum = 0;
        for (let j = 0; j < len; j++) {
          sum += vals[i - j];
        }
        result[i] = sum / len;
      }
      return result;
    }
    
    function rsiFunc(vals, len){
      if(vals.length<len+1) return new Array(vals.length).fill(null);
      const r=new Array(vals.length).fill(null);
      let gain=0, loss=0;
      for(let i=1;i<=len;i++){
        const ch = vals[i]-vals[i-1];
        if(ch>=0) gain+=ch; else loss-=ch;
      }
      let avgGain=gain/len, avgLoss=loss/len;
      r[len]=100 - 100/(1+(avgGain/(avgLoss||1e-10)));
      for(let i=len+1;i<vals.length;i++){
        const ch = vals[i]-vals[i-1];
        const g = ch>0?ch:0;
        const l = ch<0?-ch:0;
        avgGain=(avgGain*(len-1)+g)/len;
        avgLoss=(avgLoss*(len-1)+l)/len;
        const rs=avgGain/(avgLoss||1e-10);
        r[i]=100 - 100/(1+rs);
      }
      return r;
    }
    
    function macdFunc(vals, fast=12, slow=26, signal=9){
      if(vals.length<slow+signal) return {macd:[], signal:[], hist:[]};
      const emaFast=ema(vals,fast);
      const emaSlow=ema(vals,slow);
      const macd = vals.map((_,i)=>emaFast[i]-emaSlow[i]);
      const signalArr=ema(macd,signal);
      const hist = macd.map((v,i)=>v - signalArr[i]);
      return {macd, signal:signalArr, hist};
    }
    
    // ØªØ´Ø®ÛŒØµ Ø§Ù„Ú¯ÙˆÛŒ Ú©Ù†Ø¯Ù„ÛŒ
    function detectCandlePattern(bars, lookback=2){
      const patterns = [];
      const L = bars.length - 1;
      
      for(let offset = 0; offset <= lookback; offset++){
        const i = L - offset;
        if(i < 1) continue;
        
        const current = bars[i];
        const prev = bars[i-1];
        
        const open = current.open;
        const close = current.close;
        const high = current.high;
        const low = current.low;
        const body = Math.abs(close - open);
        const upperShadow = high - Math.max(open, close);
        const lowerShadow = Math.min(open, close) - low;
        const totalRange = high - low;
        const isBullish = close > open;
        const isBearish = close < open;
        
        if(totalRange === 0) continue;
        
        const bodyRatio = body / totalRange;
        const upperShadowRatio = upperShadow / totalRange;
        const lowerShadowRatio = lowerShadow / totalRange;
        
        // Ù¾ÛŒÙ† Ø¨Ø§Ø±
        if((upperShadowRatio > 0.6 && lowerShadowRatio < 0.1 && bodyRatio < 0.3) || 
           (lowerShadowRatio > 0.6 && upperShadowRatio < 0.1 && bodyRatio < 0.3)){
          
          let type = upperShadowRatio > 0.6 ? "bearish" : "bullish";
          const shadowLength = Math.max(upperShadowRatio, lowerShadowRatio);
          const strength = Math.min(100, Math.round((shadowLength * 100) + 30));
          
          if(strength > 50){
            patterns.push({
              pattern: "Pin Bar",
              type: type,
              strength: strength,
              offset: offset
            });
          }
        }
        
        // Ú†Ú©Ø´ / Ù…Ø±Ø¯ Ø¯Ø§Ø±Ø¢ÙˆÛŒØ²
        else if(offset === 0 && lowerShadowRatio > 0.6 && upperShadowRatio < 0.2 && bodyRatio < 0.3){
          const strength = Math.min(100, Math.round((lowerShadowRatio * 100) + 20));
          patterns.push({
            pattern: isBullish ? "Hammer" : "Hanging Man",
            type: isBullish ? "bullish" : "bearish",
            strength: strength,
            offset: offset
          });
        }
        
        // Ø³ØªØ§Ø±Ù‡ Ø«Ø§Ù‚Ø¨ / Ú†Ú©Ø´ Ù…Ø¹Ú©ÙˆØ³
        else if(offset === 0 && upperShadowRatio > 0.6 && lowerShadowRatio < 0.2 && bodyRatio < 0.3){
          const strength = Math.min(100, Math.round((upperShadowRatio * 100) + 20));
          patterns.push({
            pattern: isBullish ? "Inverted Hammer" : "Shooting Star",
            type: isBullish ? "bullish" : "bearish",
            strength: strength,
            offset: offset
          });
        }
        
        // Ù…Ø§Ø±ÙˆØ¨ÙˆØ²Ùˆ
        else if(bodyRatio > 0.95 && (upperShadowRatio < 0.05 && lowerShadowRatio < 0.05)){
          const strength = Math.min(100, Math.round((bodyRatio * 100) + 20));
          patterns.push({
            pattern: "Marubozu",
            type: isBullish ? "bullish" : "bearish",
            strength: strength,
            offset: offset
            });
        }
        
        // Ø§Ù„Ú¯ÙˆÛŒ Ù¾ÙˆØ´Ø´ÛŒ
        else if(offset === 0){
          const prevBody = Math.abs(prev.close - prev.open);
          const prevIsBullish = prev.close > prev.open;
          
          if(body > prevBody * 1.8){
            if(isBullish && !prevIsBullish && open <= prev.close && close >= prev.open){
              const engulfStrength = Math.min(100, Math.round((body/prevBody) * 25 + 65));
              patterns.push({
                pattern: "Bullish Engulfing",
                type: "bullish",
                strength: engulfStrength,
                offset: offset
              });
            }
            if(isBearish && prevIsBullish && open >= prev.close && close <= prev.open){
              const engulfStrength = Math.min(100, Math.round((body/prevBody) * 25 + 65));
              patterns.push({
                pattern: "Bearish Engulfing",
                type: "bearish",
                strength: engulfStrength,
                offset: offset
              });
            }
          }
        }
      }
      
      if(patterns.length > 0){
        const currentPattern = patterns.find(p => p.offset === 0);
        if(currentPattern) return currentPattern;
        return patterns[0];
      }
      
      return null;
    }
    
    // Ù‚Ø¯Ø±Øª Ú©Ù†Ø¯Ù„
    function calculateCandleStrength(bars, currentIndex){
      if(currentIndex < 14) return 50;
      return 60;
    }
    
    // TD Sequential
    function computeTDBuySellLevels(bars){
      const result = {
        TDResistance: null,
        TDSupport: null,
        breakResistance: false,
        breakSupport: false
      };
      
      if(bars.length < 20) return result;
      
      const L = bars.length - 1;
      const current = bars[L];
      const prev = bars[L-1];
      
      // Ø¬Ø³ØªØ¬ÙˆÛŒ Ù…Ù‚Ø§ÙˆÙ…Øª TD
      let tdResistance = null;
      for(let i = L; i >= Math.max(0, L - 50); i--){
        if(i < 9) continue;
        let isBuySetup = true;
        for(let j = i; j > i - 9 && j >= 0; j--){
          if(bars[j].close <= bars[j-4].close){
            isBuySetup = false;
            break;
          }
        }
        if(isBuySetup){
          let highest = -Infinity;
          for(let j = i; j > i - 9 && j >= 0; j--){
            if(bars[j].high > highest){
              highest = bars[j].high;
            }
          }
          tdResistance = highest;
          break;
        }
      }
      
      // Ø¬Ø³ØªØ¬ÙˆÛŒ Ø­Ù…Ø§ÛŒØª TD
      let tdSupport = null;
      for(let i = L; i >= Math.max(0, L - 50); i--){
        if(i < 9) continue;
        let isSellSetup = true;
        for(let j = i; j > i - 9 && j >= 0; j--){
          if(bars[j].close >= bars[j-4].close){
            isSellSetup = false;
            break;
          }
        }
        if(isSellSetup){
          let lowest = Infinity;
          for(let j = i; j > i - 9 && j >= 0; j--){
            if(bars[j].low < lowest){
              lowest = bars[j].low;
            }
          }
          tdSupport = lowest;
          break;
        }
      }
      
      result.TDResistance = tdResistance;
      result.TDSupport = tdSupport;
      
      // Ø¨Ø±Ø±Ø³ÛŒ Ø´Ú©Ø³Øª Ù…Ù‚Ø§ÙˆÙ…Øª
      if(tdResistance !== null){
        const prevClose = prev.close;
        const currentClose = current.close;
        if(prevClose < tdResistance && currentClose > tdResistance){
          result.breakResistance = true;
        }
      }
      
      // Ø¨Ø±Ø±Ø³ÛŒ Ø´Ú©Ø³Øª Ø­Ù…Ø§ÛŒØª
      if(tdSupport !== null){
        const prevClose = prev.close;
        const currentClose = current.close;
        if(prevClose > tdSupport && currentClose < tdSupport){
          result.breakSupport = true;
        }
      }
      
      return result;
    }
    
    // ØªØ­Ù„ÛŒÙ„ Ø±Ù†Ø¬
    function analyzeRangeBreakout(bars, lookback=20, threshold=0.03){
      if(bars.length < lookback + 5) return null;
      
      const L = bars.length - 1;
      const recentBars = bars.slice(-lookback);
      
      const highs = recentBars.map(b => b.high);
      const lows = recentBars.map(b => b.low);
      
      const maxHigh = Math.max(...highs);
      const minLow = Math.min(...lows);
      
      const range = maxHigh - minLow;
      const rangePercent = range / minLow;
      
      // Ø§Ú¯Ø± Ø±Ù†Ø¬ Ø¨Ø§Ø±ÛŒÚ© Ø¨Ø§Ø´Ø¯
      const isNarrowRange = rangePercent < threshold;
      
      const current = bars[L];
      const prev = bars[L-1];
      
      let breakout = null;
      
      // Ø¨Ø±Ø±Ø³ÛŒ Ø´Ú©Ø³Øª Ø¨Ø§Ù„Ø§ÛŒÛŒ
      if(current.close > maxHigh && prev.close <= maxHigh && isNarrowRange){
        breakout = {
          type: "BreakUp",
          rangeHigh: maxHigh,
          rangeLow: minLow,
          rangePercent: (rangePercent * 100).toFixed(2),
          strength: Math.min(100, Math.round((current.close - maxHigh) / range * 100))
        };
      }
      
      // Ø¨Ø±Ø±Ø³ÛŒ Ø´Ú©Ø³Øª Ù¾Ø§ÛŒÛŒÙ†ÛŒ
      if(current.close < minLow && prev.close >= minLow && isNarrowRange){
        breakout = {
          type: "BreakDown",
          rangeHigh: maxHigh,
          rangeLow: minLow,
          rangePercent: (rangePercent * 100).toFixed(2),
          strength: Math.min(100, Math.round((minLow - current.close) / range * 100))
        };
      }
      
      return breakout;
    }
    
    // ØªØ­Ù„ÛŒÙ„ Ø§ÛŒÚ†ÛŒÙ…ÙˆÚ©Ùˆ
    function analyzeIchimoku(bars){
      if(bars.length < 52) return null;
      
      const L = bars.length - 1;
      
      // Ù…Ø­Ø§Ø³Ø¨Ù‡ Tenkan-sen (Conversion Line) - 9 Ø¯ÙˆØ±Ù‡
      const tenkanPeriod = 9;
      let tenkanHigh = -Infinity;
      let tenkanLow = Infinity;
      
      const tenkanStart = Math.max(0, L - tenkanPeriod + 1);
      for(let i = tenkanStart; i <= L; i++){
        if(bars[i].high > tenkanHigh) tenkanHigh = bars[i].high;
        if(bars[i].low < tenkanLow) tenkanLow = bars[i].low;
      }
      const tenkanSen = (tenkanHigh + tenkanLow) / 2;
      
      // Ù…Ø­Ø§Ø³Ø¨Ù‡ Kijun-sen (Base Line) - 26 Ø¯ÙˆØ±Ù‡
      const kijunPeriod = 26;
      let kijunHigh = -Infinity;
      let kijunLow = Infinity;
      
      const kijunStart = Math.max(0, L - kijunPeriod + 1);
      for(let i = kijunStart; i <= L; i++){
        if(bars[i].high > kijunHigh) kijunHigh = bars[i].high;
        if(bars[i].low < kijunLow) kijunLow = bars[i].low;
      }
      const kijunSen = (kijunHigh + kijunLow) / 2;
      
      // Ù…Ø­Ø§Ø³Ø¨Ù‡ Senkou Span A (Leading Span A) - 26 Ú©Ù†Ø¯Ù„ Ø¬Ù„ÙˆØªØ±
      const senkouSpanA = (tenkanSen + kijunSen) / 2;
      
      // Ù…Ø­Ø§Ø³Ø¨Ù‡ Senkou Span B - 52 Ø¯ÙˆØ±Ù‡
      const senkouPeriod = 52;
      let senkouHigh = -Infinity;
      let senkouLow = Infinity;
      
      const senkouStart = Math.max(0, L - senkouPeriod + 1);
      for(let i = senkouStart; i <= L; i++){
        if(bars[i].high > senkouHigh) senkouHigh = bars[i].high;
        if(bars[i].low < senkouLow) senkouLow = bars[i].low;
      }
      const senkouSpanB = (senkouHigh + senkouLow) / 2;
      
      // Ø§Ø¨Ø± Ú©ÙˆÙ…Ùˆ (Kumo Cloud)
      const cloudTop = Math.max(senkouSpanA, senkouSpanB);
      const cloudBottom = Math.min(senkouSpanA, senkouSpanB);
      
      const currentPrice = bars[L].close;
      const prevPrice = bars[L-1].close;
      
      let signal = null;
      let signalType = "";
      let strength = 0;
      
      // 1. Ø¨Ø±Ø±Ø³ÛŒ Ø¹Ø¨ÙˆØ± Ù‚ÛŒÙ…Øª Ø§Ø² Ø§Ø¨Ø± Ú©ÙˆÙ…Ùˆ (Ø³ÛŒÚ¯Ù†Ø§Ù„ Ø§ØµÙ„ÛŒ)
      if(prevPrice <= cloudTop && currentPrice > cloudTop){
        signalType = "CloudBreakUp";
        strength = Math.round(((currentPrice - cloudTop) / cloudTop) * 1000) / 10;
        signal = {
          type: signalType,
          cloudTop,
          cloudBottom,
          cloudStrength: strength,
          tenkanSen,
          kijunSen,
          inCloud: currentPrice <= cloudTop && currentPrice >= cloudBottom,
          aboveCloud: currentPrice > cloudTop,
          belowCloud: currentPrice < cloudBottom
        };
      } 
      else if(prevPrice >= cloudBottom && currentPrice < cloudBottom){
        signalType = "CloudBreakDown";
        strength = Math.round(((cloudBottom - currentPrice) / cloudBottom) * 1000) / 10;
        signal = {
          type: signalType,
          cloudTop,
          cloudBottom,
          cloudStrength: strength,
          tenkanSen,
          kijunSen,
          inCloud: currentPrice <= cloudTop && currentPrice >= cloudBottom,
          aboveCloud: currentPrice > cloudTop,
          belowCloud: currentPrice < cloudBottom
        };
      }
      
      // 2. Ø¨Ø±Ø±Ø³ÛŒ Ú©Ø±Ø§Ø³ ØªÙ†Ú©Ø§Ù† Ùˆ Ú©ÛŒØ¬ÙˆÙ† (Ø³ÛŒÚ¯Ù†Ø§Ù„ Ø«Ø§Ù†ÙˆÛŒÙ‡)
      if(!signal){
        let prevTenkanHigh = -Infinity;
        let prevTenkanLow = Infinity;
        const prevTenkanStart = Math.max(0, L-1 - tenkanPeriod + 1);
        for(let i = prevTenkanStart; i <= L-1; i++){
          if(bars[i].high > prevTenkanHigh) prevTenkanHigh = bars[i].high;
          if(bars[i].low < prevTenkanLow) prevTenkanLow = bars[i].low;
        }
        const prevTenkanSen = (prevTenkanHigh + prevTenkanLow) / 2;
        
        let prevKijunHigh = -Infinity;
        let prevKijunLow = Infinity;
        const prevKijunStart = Math.max(0, L-1 - kijunPeriod + 1);
        for(let i = prevKijunStart; i <= L-1; i++){
          if(bars[i].high > prevKijunHigh) prevKijunHigh = bars[i].high;
          if(bars[i].low < prevKijunLow) prevKijunLow = bars[i].low;
        }
        const prevKijunSen = (prevKijunHigh + prevKijunLow) / 2;
        
        // ØªØ´Ø®ÛŒØµ Ú©Ø±Ø§Ø³ ØµØ¹ÙˆØ¯ÛŒ
        if(prevTenkanSen <= prevKijunSen && tenkanSen > kijunSen){
          signalType = "TKCrossUp";
          strength = Math.round(((tenkanSen - kijunSen) / kijunSen) * 1000) / 10;
          signal = {
            type: signalType,
            cloudTop,
            cloudBottom,
            cloudStrength: strength,
            tenkanSen,
            kijunSen,
            inCloud: currentPrice <= cloudTop && currentPrice >= cloudBottom,
            aboveCloud: currentPrice > cloudTop,
            belowCloud: currentPrice < cloudBottom
          };
        } 
        // ØªØ´Ø®ÛŒØµ Ú©Ø±Ø§Ø³ Ù†Ø²ÙˆÙ„ÛŒ
        else if(prevTenkanSen >= prevKijunSen && tenkanSen < kijunSen){
          signalType = "TKCrossDown";
          strength = Math.round(((kijunSen - tenkanSen) / tenkanSen) * 1000) / 10;
          signal = {
            type: signalType,
            cloudTop,
            cloudBottom,
            cloudStrength: strength,
            tenkanSen,
            kijunSen,
            inCloud: currentPrice <= cloudTop && currentPrice >= cloudBottom,
            aboveCloud: currentPrice > cloudTop,
            belowCloud: currentPrice < cloudBottom
          };
        }
      }
      
      // 3. Ø¨Ø±Ø±Ø³ÛŒ Ù…ÙˆÙ‚Ø¹ÛŒØª Ù‚ÛŒÙ…Øª Ù†Ø³Ø¨Øª Ø¨Ù‡ Ø§Ø¨Ø± (Ø³ÛŒÚ¯Ù†Ø§Ù„ Ø¶Ø¹ÛŒÙâ€ŒØªØ±)
      if(!signal){
        if(currentPrice > cloudTop){
          signalType = "AboveCloud";
          strength = 30;
          signal = {
            type: signalType,
            cloudTop,
            cloudBottom,
            cloudStrength: strength,
            tenkanSen,
            kijunSen,
            inCloud: false,
            aboveCloud: true,
            belowCloud: false
          };
        }
        else if(currentPrice < cloudBottom){
          signalType = "BelowCloud";
          strength = 30;
          signal = {
            type: signalType,
            cloudTop,
            cloudBottom,
            cloudStrength: strength,
            tenkanSen,
            kijunSen,
            inCloud: false,
            aboveCloud: false,
            belowCloud: true
          };
        }
        else if(currentPrice <= cloudTop && currentPrice >= cloudBottom){
          signalType = "InCloud";
          strength = 10;
          signal = {
            type: signalType,
            cloudTop,
            cloudBottom,
            cloudStrength: strength,
            tenkanSen,
            kijunSen,
            inCloud: true,
            aboveCloud: false,
            belowCloud: false
          };
        }
      }
      
      return signal;
    }
    
    // ØªØ­Ù„ÛŒÙ„ Ú©Ø±Ø§Ø³ EMA
    function analyzeEMACross(bars, shortPeriod=9, longPeriod=21){
      if(bars.length < longPeriod + 5) return null;
      
      const closes = bars.map(b => b.close);
      const emaShort = ema(closes, shortPeriod);
      const emaLong = ema(closes, longPeriod);
      
      const L = bars.length - 1;
      
      // Ø¨Ø±Ø±Ø³ÛŒ Ú©Ø±Ø§Ø³
      if(emaShort[L-1] <= emaLong[L-1] && emaShort[L] > emaLong[L]){
        return {
          type: "EMACrossUp",
          shortEMA: emaShort[L],
          longEMA: emaLong[L],
          difference: ((emaShort[L] - emaLong[L]) / emaLong[L] * 100).toFixed(2)
        };
      } else if(emaShort[L-1] >= emaLong[L-1] && emaShort[L] < emaLong[L]){
        return {
          type: "EMACrossDown",
          shortEMA: emaShort[L],
          longEMA: emaLong[L],
          difference: ((emaLong[L] - emaShort[L]) / emaShort[L] * 100).toFixed(2)
        };
      }
      
      return null;
    }
    
    // ============================================
    // ØªØ­Ù„ÛŒÙ„ Ø§ØµÙ„ÛŒ Ø¨Ø§ Ø§Ù…ØªÛŒØ§Ø²Ø¯Ù‡ÛŒ ØªØ±Ú©ÛŒØ¨ÛŒ (Ø¨Ù‡Ø¨ÙˆØ¯ ÛŒØ§ÙØªÙ‡)
    // ============================================
    
    function analyzeSymbolProTL(bars, pivLR, maLen, useMA, marketData = {}){
      const maxLines = 10;
      const breakThresholdPct = 0.1;
      
      if(bars.length < Math.max(maLen+10, 60)) return null;
      
      const closes = bars.map(b=>b.close);
      const highs = bars.map(b=>b.high);
      const lows  = bars.map(b=>b.low);
      
      const emaArr = ema(closes, maLen);
      const rsiArr = rsiFunc(closes,14);
      const macdObj = macdFunc(closes,12,26,9);
      
      // ØªØ­Ù„ÛŒÙ„ Ù‡Ù…Ù‡ Ø§Ø³ØªØ±Ø§ØªÚ˜ÛŒâ€ŒÙ‡Ø§ Ø¨Ù‡ ØµÙˆØ±Øª Ù…Ø³ØªÙ‚Ù„
      const candlePattern = detectCandlePattern(bars, 2);
      const candleStrength = candlePattern ? candlePattern.strength : calculateCandleStrength(bars, bars.length-1);
      
      const rangeAnalysis = analyzeRangeBreakout(bars);
      const ichimokuAnalysis = analyzeIchimoku(bars);
      const emaCrossAnalysis = analyzeEMACross(bars);
      
      const L = bars.length-1;
      const prev = bars[L-1];
      const current = bars[L];
      const prevClose = prev ? prev.close : closes[L-1];
      const lastClose = current.close;
      const lastEMA = emaArr[L];
      const lastRSI = rsiArr[L];
      
      const tdLevels = computeTDBuySellLevels(bars);
      const breakRes = tdLevels.breakResistance;
      const breakSup = tdLevels.breakSupport;
      const TDResistance = tdLevels.TDResistance;
      const TDSupport = tdLevels.TDSupport;
      
      // ØªØ­Ù„ÛŒÙ„ Ø®Ø· Ø±ÙˆÙ†Ø¯
      const pivotLows = [];
      const pivotLowIdx = [];
      const pivotHighs = [];
      const pivotHighIdx = [];
      
      for(let i=0;i<bars.length;i++){
        const pl = pivotLowVal(lows,pivLR,pivLR,i);
        if(pl!=null){
          pivotLows.push(pl);
          pivotLowIdx.push(i);
          if(pivotLows.length>10){
            pivotLows.shift();
            pivotLowIdx.shift();
          }
        }
        const ph = pivotHighVal(highs,pivLR,pivLR,i);
        if(ph!=null){
          pivotHighs.push(ph);
          pivotHighIdx.push(i);
          if(pivotHighs.length>10){
            pivotHighs.shift();
            pivotHighIdx.shift();
          }
        }
      }
      
      const uptrendLines=[];
      const downtrendLines=[];
      
      if(pivotLows.length>=2){
        const current_low = pivotLows[pivotLows.length-1];
        const current_bar = pivotLowIdx[pivotLowIdx.length-1];
        for(let i=pivotLows.length-2;i>=0;i--){
          const prev_low = pivotLows[i];
          const prev_bar = pivotLowIdx[i];
          if(current_low > prev_low){
            uptrendLines.push({
              x1:prev_bar,
              y1:prev_low,
              x2:current_bar,
              y2:current_low,
              isUp:true,
              broken:false
            });
            break;
          }
        }
      }
      
      if(pivotHighs.length>=2){
        const current_high = pivotHighs[pivotHighs.length-1];
        const current_bar = pivotHighIdx[pivotHighIdx.length-1];
        for(let i=pivotHighs.length-2;i>=0;i--){
          const prev_high = pivotHighs[i];
          const prev_bar = pivotHighIdx[i];
          if(current_high < prev_high){
            downtrendLines.push({
              x1:prev_bar,
              y1:prev_high,
              x2:current_bar,
              y2:current_high,
              isUp:false,
              broken:false
            });
            break;
          }
        }
      }
      
      let tlSignal=null;
      
      for(const line of uptrendLines){
        const lp = linePrice(line, L);
        if(lp==null) continue;
        const th = lp*(1 - breakThresholdPct/100);
        if(lastClose < th){
          tlSignal = "BreakDown";
          line.broken = true;
          break;
        }
      }
      
      if(!tlSignal){
        for(const line of downtrendLines){
          const lp = linePrice(line, L);
          if(lp==null) continue;
          const th = lp*(1 + breakThresholdPct/100);
          if(lastClose > th){
            tlSignal = "BreakUp";
            line.broken = true;
            break;
          }
        }
      }
      
      if(useMA==="longs" && tlSignal==="BreakUp" && !(lastClose>lastEMA)) tlSignal=null;
      if(useMA==="shorts" && tlSignal==="BreakDown" && !(lastClose<lastEMA)) tlSignal=null;
      if(useMA==="both"){
        if(tlSignal==="BreakUp" && !(lastClose>lastEMA)) tlSignal=null;
        if(tlSignal==="BreakDown" && !(lastClose<lastEMA)) tlSignal=null;
      }
      
      // Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø§Ù…ØªÛŒØ§Ø² ØªØ±Ú©ÛŒØ¨ÛŒ
      const strategies = {
        tl: tlSignal ? 1 : 0,
        td: (breakRes || breakSup) ? 1 : 0,
        candle: candlePattern ? 1 : 0,
        range: rangeAnalysis ? 1 : 0,
        ichimoku: ichimokuAnalysis ? 1 : 0,
        emaCross: emaCrossAnalysis ? 1 : 0,
        volumeMCap: 0 // Ø¨Ø¹Ø¯Ø§Ù‹ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯
      };
      
      // ØªØ¹Ø¯Ø§Ø¯ Ø§Ø³ØªØ±Ø§ØªÚ˜ÛŒâ€ŒÙ‡Ø§ÛŒ ÙØ¹Ø§Ù„
      const activeStrategies = Object.values(strategies).filter(v => v === 1).length;
      
      // Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø§Ù…ØªÛŒØ§Ø² Ø¨Ø± Ø§Ø³Ø§Ø³ ÙˆØ²Ù†â€ŒÙ‡Ø§
      let combinedScore = 0;
      const weighting = scoreWeightingSelect.value;
      
      if(weighting === "equal") {
        combinedScore = activeStrategies * 14.28;
      } else if(weighting === "priority") {
        combinedScore = (strategies.tl * 30) + (strategies.td * 25) + 
                       (strategies.candle * 15) + (strategies.range * 10) +
                       (strategies.ichimoku * 10) + (strategies.emaCross * 10);
      } else if(weighting === "custom") {
        combinedScore = (strategies.tl * parseInt(weightTL.value) || 0) + 
                       (strategies.td * parseInt(weightTD.value) || 0) + 
                       (strategies.candle * parseInt(weightCandle.value) || 0) +
                       (strategies.range * 10) + (strategies.ichimoku * 10) + 
                       (strategies.emaCross * 10);
      }
      
      combinedScore = Math.min(100, Math.round(combinedScore));
      
      // ØªØ­Ù„ÛŒÙ„ Ø§ØµÙ„ÛŒ
      const analysis = {
        tlSignal,
        breakRes,
        breakSup,
        TDResistance,
        TDSupport,
        rangeAnalysis,
        ichimokuAnalysis,
        emaCrossAnalysis,
        emaArr,
        rsiArr,
        macdObj,
        candlePattern,
        candleStrength,
        lastRSI,
        uptrendLines,
        downtrendLines,
        strategies,
        activeStrategies,
        combinedScore
      };
      
      // Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø§Ø¶Ø§ÙÛŒ
      return addExtraInfo(bars, analysis);
    }
    
    // ØªÙˆØ§Ø¨Ø¹ Ú©Ù…Ú©ÛŒ
    function pivotLowVal(arr, L, R, i){
      if(i<L || i>arr.length-1-R) return null;
      const v=arr[i];
      for(let x=i-L;x<=i+R;x++) if(arr[x]<v) return null;
      return v;
    }
    
    function pivotHighVal(arr,L,R,i){
      if(i<L || i>arr.length-1-R) return null;
      const v=arr[i];
      for(let x=i-L;x<=i+R;x++) if(arr[x]>v) return null;
      return v;
    }
    
    function linePrice(line, idx){
      if(!line) return null;
      if(line.x2===line.x1) return line.y2;
      const t=(idx-line.x1)/(line.x2-line.x1);
      return line.y1 + t*(line.y2-line.y1);
    }
    
    // ============================================
    // Ù†Ù…Ø§ÛŒØ´ Ú†Ø§Ø±Øª Ø­Ø±ÙÙ‡â€ŒØ§ÛŒ (Ø¯Ø³Øª Ù†Ø®ÙˆØ±Ø¯Ù‡)
    // ============================================
    
    function drawChart(bars, analysis, showIndicators) {
      resizeCanvas();
      currentChartData = bars;
      currentAnalysis = analysis;
      
      const rect = chartCanvas.getBoundingClientRect();
      const w = rect.width;
      const h = rect.height;
      
      ctx.fillStyle = 'rgba(2, 6, 23, 0.95)';
      ctx.fillRect(0, 0, w, h);
      
      const hasRSI = showIndicators === "rsi" || showIndicators === "both";
      const hasMACD = showIndicators === "macd" || showIndicators === "both";
      
      // Ø§Ø±ØªÙØ§Ø¹ Ø¨Ø®Ø´â€ŒÙ‡Ø§
      const priceHeight = hasRSI || hasMACD ? h * 0.60 : h * 0.85;
      const rsiHeight = hasRSI ? h * 0.15 : 0;
      const macdHeight = hasMACD ? h * 0.15 : 0;
      
      // Ø­Ø§Ø´ÛŒÙ‡â€ŒÙ‡Ø§
      const padding = { left: 60, right: 20, top: 20, bottom: 20 };
      
      // Ù…Ø­Ø§Ø³Ø¨Ù‡ Ù…Ø­Ø¯ÙˆØ¯Ù‡ Ù†Ù…Ø§ÛŒØ´
      const totalBars = bars.length;
      const startIdx = Math.max(0, totalBars - chartViewState.visibleBars - chartViewState.offset);
      const endIdx = Math.min(totalBars, startIdx + chartViewState.visibleBars);
      const visibleBars = bars.slice(startIdx, endIdx);
      
      if (visibleBars.length < 5) return;
      
      // Ù¾ÛŒØ¯Ø§ Ú©Ø±Ø¯Ù† min Ùˆ max Ø¨Ø±Ø§ÛŒ Ù…Ù‚ÛŒØ§Ø³â€ŒØ¨Ù†Ø¯ÛŒ
      let minPrice = Infinity;
      let maxPrice = -Infinity;
      let maxVolume = 0;
      
      visibleBars.forEach(bar => {
        minPrice = Math.min(minPrice, bar.low);
        maxPrice = Math.max(maxPrice, bar.high);
        maxVolume = Math.max(maxVolume, bar.volume);
      });
      
      // Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† Ø­Ø§Ø´ÛŒÙ‡ Ø¨Ù‡ min/max
      const priceRange = maxPrice - minPrice;
      minPrice -= priceRange * 0.05;
      maxPrice += priceRange * 0.05;
      
      // ØªÙˆØ§Ø¨Ø¹ ØªØ¨Ø¯ÛŒÙ„ Ù…Ø®ØªØµØ§Øª
      const priceToY = (price) => {
        return padding.top + (maxPrice - price) * (priceHeight - padding.top - padding.bottom) / (maxPrice - minPrice);
      };
      
      const timeToX = (time, index) => {
        const totalVisible = visibleBars.length;
        const barWidth = (w - padding.left - padding.right) / totalVisible;
        return padding.left + (index * barWidth) + (barWidth / 2);
      };
      
      const volumeToHeight = (volume) => {
        return (volume / maxVolume) * (priceHeight * 0.2);
      };
      
      // Ø±Ø³Ù… Ú¯Ø±ÛŒØ¯ Ø§ÙÙ‚ÛŒ
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
      ctx.lineWidth = 0.5;
      ctx.setLineDash([2, 2]);
      
      // Ø®Ø·ÙˆØ· Ù‚ÛŒÙ…Øª
      const priceLevels = 8;
      for (let i = 0; i <= priceLevels; i++) {
        const price = minPrice + (priceRange * i / priceLevels);
        const y = priceToY(price);
        
        ctx.beginPath();
        ctx.moveTo(padding.left, y);
        ctx.lineTo(w - padding.right, y);
        ctx.stroke();
        
        // Ù†Ù…Ø§ÛŒØ´ Ù‚ÛŒÙ…Øª
        ctx.fillStyle = '#94a3b8';
        ctx.font = '10px Vazirmatn';
        ctx.textAlign = 'left';
        ctx.fillText(price.toFixed(2), padding.left - 55, y + 3);
      }
      
      ctx.setLineDash([]);
      
      // Ø±Ø³Ù… Ú©Ù†Ø¯Ù„â€ŒÙ‡Ø§
      const barSpacing = 0.8;
      const barWidth = ((w - padding.left - padding.right) / visibleBars.length) * barSpacing;
      
      visibleBars.forEach((bar, index) => {
        const x = timeToX(bar.time, index);
        const yOpen = priceToY(bar.open);
        const yClose = priceToY(bar.close);
        const yHigh = priceToY(bar.high);
        const yLow = priceToY(bar.low);
        
        const isBullish = bar.close >= bar.open;
        
        // Ø³Ø§ÛŒÙ‡â€ŒÙ‡Ø§
        ctx.strokeStyle = isBullish ? '#22c55e' : '#ef4444';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(x, yHigh);
        ctx.lineTo(x, yLow);
        ctx.stroke();
        
        // Ø¨Ø¯Ù†Ù‡
        const top = Math.min(yOpen, yClose);
        const height = Math.abs(yOpen - yClose);
        
        if (height > 0) {
          ctx.fillStyle = isBullish ? '#22c55e' : '#ef4444';
          ctx.fillRect(x - barWidth/2, top, barWidth, height);
        } else {
          ctx.strokeStyle = isBullish ? '#22c55e' : '#ef4444';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(x - barWidth/2, top);
          ctx.lineTo(x + barWidth/2, top);
          ctx.stroke();
        }
        
        // Ø­Ø¬Ù…
        if (maxVolume > 0) {
          const volumeHeight = volumeToHeight(bar.volume);
          const volumeY = priceHeight - volumeHeight;
          
          ctx.fillStyle = isBullish ? 'rgba(34, 197, 94, 0.3)' : 'rgba(239, 68, 68, 0.3)';
          ctx.fillRect(x - barWidth/2, volumeY, barWidth, volumeHeight);
        }
      });
      
      // Ø±Ø³Ù… ØªØ±Ù†Ø¯Ù„Ø§ÛŒÙ†â€ŒÙ‡Ø§
      if (analysis.uptrendLines || analysis.downtrendLines) {
        const allLines = [...(analysis.uptrendLines || []), ...(analysis.downtrendLines || [])];
        
        allLines.forEach(line => {
          const lineStartIdx = line.x1;
          const lineEndIdx = line.x2;
          
          if (lineStartIdx >= startIdx && lineEndIdx <= endIdx) {
            const x1 = timeToX(bars[lineStartIdx].time, lineStartIdx - startIdx);
            const y1 = priceToY(line.y1);
            const x2 = timeToX(bars[lineEndIdx].time, lineEndIdx - startIdx);
            const y2 = priceToY(line.y2);
            
            ctx.strokeStyle = line.broken ? '#94a3b8' : (line.isUp ? '#22c55e' : '#f97316');
            ctx.lineWidth = line.broken ? 1.5 : 2;
            
            if (line.broken) ctx.setLineDash([5, 3]);
            
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
            
            ctx.setLineDash([]);
          }
        });
      }
      
      // Ø±Ø³Ù… Ø³Ø·ÙˆØ­ TD
      if (analysis.TDResistance) {
        const y = priceToY(analysis.TDResistance);
        ctx.strokeStyle = 'rgba(168, 85, 247, 0.8)';
        ctx.lineWidth = 1.5;
        ctx.setLineDash([5, 3]);
        ctx.beginPath();
        ctx.moveTo(padding.left, y);
        ctx.lineTo(w - padding.right, y);
        ctx.stroke();
        
        ctx.fillStyle = '#a855f7';
        ctx.font = '10px Vazirmatn';
        ctx.textAlign = 'right';
        ctx.fillText(`TD Res: ${analysis.TDResistance.toFixed(2)}`, w - padding.right - 5, y - 5);
      }
      
      if (analysis.TDSupport) {
        const y = priceToY(analysis.TDSupport);
        ctx.strokeStyle = 'rgba(34, 197, 94, 0.8)';
        ctx.lineWidth = 1.5;
        ctx.setLineDash([5, 3]);
        ctx.beginPath();
        ctx.moveTo(padding.left, y);
        ctx.lineTo(w - padding.right, y);
        ctx.stroke();
        
        ctx.fillStyle = '#22c55e';
        ctx.font = '10px Vazirmatn';
        ctx.textAlign = 'right';
        ctx.fillText(`TD Sup: ${analysis.TDSupport.toFixed(2)}`, w - padding.right - 5, y + 15);
      }
      ctx.setLineDash([]);
      
      // Ø±Ø³Ù… EMA
      if (analysis.emaArr && analysis.emaArr.length > 0) {
        ctx.strokeStyle = 'rgba(59, 130, 246, 0.8)';
        ctx.lineWidth = 1.2;
        ctx.beginPath();
        
        let firstPoint = true;
        visibleBars.forEach((bar, index) => {
          const globalIndex = startIdx + index;
          if (globalIndex < analysis.emaArr.length) {
            const x = timeToX(bar.time, index);
            const y = priceToY(analysis.emaArr[globalIndex]);
            
            if (firstPoint) {
              ctx.moveTo(x, y);
              firstPoint = false;
            } else {
              ctx.lineTo(x, y);
            }
          }
        });
        ctx.stroke();
        
        const lastEMA = analysis.emaArr[endIdx - 1];
        if (lastEMA) {
          const y = priceToY(lastEMA);
          ctx.fillStyle = '#3b82f6';
          ctx.font = '10px Vazirmatn';
          ctx.textAlign = 'left';
          ctx.fillText(`EMA: ${lastEMA.toFixed(2)}`, padding.left + 5, y - 5);
        }
      }
      
      // Ø±Ø³Ù… RSI
      if (hasRSI && analysis.rsiArr && analysis.rsiArr.length > 0) {
        const rsiTop = priceHeight + 10;
        const rsiBottom = rsiTop + rsiHeight;
        
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
        ctx.lineWidth = 0.5;
        ctx.setLineDash([2, 2]);
        
        const y70 = rsiTop + (rsiBottom - rsiTop) * 0.3;
        ctx.beginPath();
        ctx.moveTo(padding.left, y70);
        ctx.lineTo(w - padding.right, y70);
        ctx.stroke();
        
        const y50 = rsiTop + (rsiBottom - rsiTop) * 0.5;
        ctx.beginPath();
        ctx.moveTo(padding.left, y50);
        ctx.lineTo(w - padding.right, y50);
        ctx.stroke();
        
        const y30 = rsiTop + (rsiBottom - rsiTop) * 0.7;
        ctx.beginPath();
        ctx.moveTo(padding.left, y30);
        ctx.lineTo(w - padding.right, y30);
        ctx.stroke();
        
        ctx.setLineDash([]);
        
        ctx.strokeStyle = '#2dd4bf';
        ctx.lineWidth = 1.2;
        ctx.beginPath();
        
        let firstRSI = true;
        visibleBars.forEach((bar, index) => {
          const globalIndex = startIdx + index;
          if (globalIndex < analysis.rsiArr.length && analysis.rsiArr[globalIndex] !== null) {
            const x = timeToX(bar.time, index);
            const rsiValue = analysis.rsiArr[globalIndex];
            const y = rsiBottom - ((rsiValue - 0) / 100) * (rsiBottom - rsiTop);
            
            if (firstRSI) {
              ctx.moveTo(x, y);
              firstRSI = false;
            } else {
              ctx.lineTo(x, y);
            }
          }
        });
        ctx.stroke();
        
        const lastRSI = analysis.rsiArr[endIdx - 1];
        if (lastRSI !== null) {
          const y = rsiBottom - ((lastRSI - 0) / 100) * (rsiBottom - rsiTop);
          ctx.fillStyle = '#2dd4bf';
          ctx.font = '10px Vazirmatn';
          ctx.textAlign = 'left';
          ctx.fillText(`RSI: ${lastRSI.toFixed(1)}`, padding.left + 5, y - 5);
        }
      }
      
      // Ø±Ø³Ù… MACD
      if (hasMACD && analysis.macdObj) {
        const macdTop = priceHeight + rsiHeight + 15;
        const macdBottom = macdTop + macdHeight;
        
        const zeroY = macdTop + (macdBottom - macdTop) / 2;
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
        ctx.lineWidth = 0.5;
        ctx.beginPath();
        ctx.moveTo(padding.left, zeroY);
        ctx.lineTo(w - padding.right, zeroY);
        ctx.stroke();
        
        const macdData = analysis.macdObj;
        visibleBars.forEach((bar, index) => {
          const globalIndex = startIdx + index;
          if (globalIndex < macdData.hist.length && macdData.hist[globalIndex] !== null) {
            const x = timeToX(bar.time, index);
            const histValue = macdData.hist[globalIndex];
            const barHeight = Math.abs(histValue) * 10;
            const y = histValue >= 0 ? zeroY - barHeight : zeroY;
            
            ctx.fillStyle = histValue >= 0 ? 'rgba(34, 197, 94, 0.6)' : 'rgba(239, 68, 68, 0.6)';
            ctx.fillRect(x - barWidth/3, y, barWidth * 0.66, barHeight);
          }
        });
        
        ctx.strokeStyle = 'rgba(59, 130, 246, 0.8)';
        ctx.lineWidth = 1.2;
        ctx.beginPath();
        
        let firstMACD = true;
        visibleBars.forEach((bar, index) => {
          const globalIndex = startIdx + index;
          if (globalIndex < macdData.macd.length && macdData.macd[globalIndex] !== null) {
            const x = timeToX(bar.time, index);
            const macdValue = macdData.macd[globalIndex];
            const y = zeroY - (macdValue * 10);
            
            if (firstMACD) {
              ctx.moveTo(x, y);
              firstMACD = false;
            } else {
              ctx.lineTo(x, y);
            }
          }
        });
        ctx.stroke();
        
        ctx.strokeStyle = 'rgba(245, 158, 11, 0.8)';
        ctx.lineWidth = 1.2;
        ctx.beginPath();
        
        let firstSignal = true;
        visibleBars.forEach((bar, index) => {
          const globalIndex = startIdx + index;
          if (globalIndex < macdData.signal.length && macdData.signal[globalIndex] !== null) {
            const x = timeToX(bar.time, index);
            const signalValue = macdData.signal[globalIndex];
            const y = zeroY - (signalValue * 10);
            
            if (firstSignal) {
              ctx.moveTo(x, y);
              firstSignal = false;
            } else {
              ctx.lineTo(x, y);
            }
          }
        });
        ctx.stroke();
      }
      
      // Ù†Ù…Ø§ÛŒØ´ Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø§Ø¶Ø§ÙÛŒ
      ctx.fillStyle = '#94a3b8';
      ctx.font = '10px Vazirmatn';
      ctx.textAlign = 'right';
      
      const firstTime = new Date(visibleBars[0].time);
      const lastTime = new Date(visibleBars[visibleBars.length - 1].time);
      const timeRangeText = `${firstTime.toLocaleDateString('fa-IR')} - ${lastTime.toLocaleDateString('fa-IR')}`;
      ctx.fillText(timeRangeText, w - padding.right, h - 5);
      
      ctx.textAlign = 'left';
      ctx.fillText(`Ú©Ù†Ø¯Ù„â€ŒÙ‡Ø§: ${visibleBars.length}/${bars.length}`, padding.left, h - 5);
    }
    
    // Ú©Ù†ØªØ±Ù„â€ŒÙ‡Ø§ÛŒ Ú†Ø§Ø±Øª
    zoomInBtn.addEventListener('click', () => {
      chartViewState.zoom *= 1.2;
      chartViewState.visibleBars = Math.max(20, Math.floor(100 / chartViewState.zoom));
      if (currentChartData && currentAnalysis) {
        drawChart(currentChartData, currentAnalysis, showIndicatorsSelect.value);
      }
    });
    
    zoomOutBtn.addEventListener('click', () => {
      chartViewState.zoom /= 1.2;
      chartViewState.visibleBars = Math.min(200, Math.floor(100 / chartViewState.zoom));
      if (currentChartData && currentAnalysis) {
        drawChart(currentChartData, currentAnalysis, showIndicatorsSelect.value);
      }
    });
    
    panLeftBtn.addEventListener('click', () => {
      chartViewState.offset = Math.min(currentChartData.length - chartViewState.visibleBars, 
        chartViewState.offset + 10);
      if (currentChartData && currentAnalysis) {
        drawChart(currentChartData, currentAnalysis, showIndicatorsSelect.value);
      }
    });
    
    panRightBtn.addEventListener('click', () => {
      chartViewState.offset = Math.max(0, chartViewState.offset - 10);
      if (currentChartData && currentAnalysis) {
        drawChart(currentChartData, currentAnalysis, showIndicatorsSelect.value);
      }
    });
    
    resetChartBtn.addEventListener('click', () => {
      chartViewState = {
        offset: 0,
        visibleBars: 100,
        zoom: 1.0
      };
      if (currentChartData && currentAnalysis) {
        drawChart(currentChartData, currentAnalysis, showIndicatorsSelect.value);
      }
    });
    
    // ============================================
    // Ù…Ù†Ø·Ù‚ ÙÛŒÙ„ØªØ±Ø§Ø³ÛŒÙˆÙ† Ù¾ÛŒØ´Ø±ÙØªÙ‡
    // ============================================
    
    function filterResults(results, marketData) {
      const filterTL = document.getElementById("filterTL").checked;
      const filterTD = document.getElementById("filterTD").checked;
      const filterCandle = document.getElementById("filterCandle").checked;
      const filterRange = document.getElementById("filterRange").checked;
      const filterIchimoku = document.getElementById("filterIchimoku").checked;
      const filterEMACross = document.getElementById("filterEMACross").checked;
      const filterVolumeMCap = document.getElementById("filterVolumeMCap").checked;
      const volumeThreshold = parseFloat(volumeMCapThreshold.value) || 1;
      
      const combinationMode = document.querySelector('input[name="combinationMode"]:checked').value;
      const minStrategies = parseInt(minStrategiesInput.value) || 2;
      
      // ÙÛŒÙ„ØªØ± Ø­Ø¬Ù…/Ù…Ø§Ø±Ú©Øªâ€ŒÚ©Ù¾
      let filteredByVolume = results;
      if (filterVolumeMCap) {
        filteredByVolume = results.filter(r => {
          const marketInfo = marketData[r.sym];
          return marketInfo && marketInfo.volumeMCapRatio >= volumeThreshold;
        });
      }
      
      // Ø§Ø¹Ù…Ø§Ù„ Ù…Ù†Ø·Ù‚ ØªØ±Ú©ÛŒØ¨
      return filteredByVolume.filter(r => {
        const a = r.analysis;
        const strategies = a.strategies;
        
        let activeSelectedStrategies = 0;
        
        if (filterTL && strategies.tl) activeSelectedStrategies++;
        if (filterTD && strategies.td) activeSelectedStrategies++;
        if (filterCandle && strategies.candle) activeSelectedStrategies++;
        if (filterRange && strategies.range) activeSelectedStrategies++;
        if (filterIchimoku && strategies.ichimoku) activeSelectedStrategies++;
        if (filterEMACross && strategies.emaCross) activeSelectedStrategies++;
        
        if (combinationMode === "OR") {
          return activeSelectedStrategies > 0;
        } 
        else if (combinationMode === "AND") {
          const totalSelected = [filterTL, filterTD, filterCandle, filterRange, filterIchimoku, filterEMACross]
            .filter(v => v).length;
          return activeSelectedStrategies === totalSelected;
        }
        else if (combinationMode === "MIN") {
          return activeSelectedStrategies >= minStrategies;
        }
        
        return false;
      });
    }
    
    // ØªØ§Ø¨Ø¹ Ø¨Ø±Ø§ÛŒ Ù†Ù…Ø§ÛŒØ´ Ø­Ø¬Ù…/Ù…Ø§Ø±Ú©Øªâ€ŒÚ©Ù¾
    function getVolumeMCapBadge(ratio) {
      if (ratio >= 3) {
        return `<span class="volume-mcap-badge vm-high">${ratio.toFixed(1)}%</span>`;
      } else if (ratio >= 1) {
        return `<span class="volume-mcap-badge vm-medium">${ratio.toFixed(1)}%</span>`;
      } else {
        return `<span class="volume-mcap-badge vm-low">${ratio.toFixed(1)}%</span>`;
      }
    }
    
    // ============================================
    // Ù…Ù†Ø·Ù‚ Ø§ØµÙ„ÛŒ Ø§Ø³Ú©Ù† (Ø¨Ù‡Ø¨ÙˆØ¯ ÛŒØ§ÙØªÙ‡)
    // ============================================
    
    let lastSignalsKeySet = new Set();
    let autoScanTimer = null;
    let currentApiStatus = {};
    
    function getActiveTFs(){
      return [...tfGrid.querySelectorAll(".tf-btn.active")].map(b=>b.textContent);
    }
    
    async function scanOnce(manual=false){
      scanBtn.disabled=true;
      scanBtn.innerHTML='<span class="loader"></span> Ø¯Ø± Ø­Ø§Ù„ Ø§Ø³Ú©Ù†...';
      resultsBody.innerHTML="";
      chartContainer.style.display="none";
      
      const tfs = getActiveTFs();
      if(!tfs.length){
        statusEl.textContent="Ø­Ø¯Ø§Ù‚Ù„ ÛŒÚ© ØªØ§ÛŒÙ…â€ŒÙØ±ÛŒÙ… Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†.";
        scanBtn.disabled=false;
        scanBtn.textContent="ğŸ” Ø§Ø³Ú©Ù† Ø¯Ø³ØªÛŒ";
        return;
      }
      
      const pivLR = +pivLRInput.value || 5;
      const maLen = +maLenInput.value || 200;
      const useMA = useMASelect.value;
      const count = parseInt(symbolCountSelect.value);
      
      statusEl.textContent="Ø¯Ø± Ø­Ø§Ù„ Ø¯Ø±ÛŒØ§ÙØª Ù„ÛŒØ³Øª Ù†Ù…Ø§Ø¯Ù‡Ø§...";
      let symbols = [];
      let marketData = {};
      
      try {
        symbols = await fetchTopSymbols();
        statusEl.textContent="Ø¯Ø± Ø­Ø§Ù„ Ø¯Ø±ÛŒØ§ÙØª Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ù…Ø§Ø±Ú©Øª...";
        marketData = await fetchMarketData(symbols);
      } catch(e) {
        console.error("Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§:", e);
        statusEl.textContent="Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ù„ÛŒØ³Øª Ù¾ÛŒØ´â€ŒÙØ±Ø¶ Ù†Ù…Ø§Ø¯Ù‡Ø§...";
        symbols = ["BTCUSDT", "ETHUSDT", "BNBUSDT", "ADAUSDT", "XRPUSDT", 
                   "SOLUSDT", "DOTUSDT", "DOGEUSDT", "AVAXUSDT", "MATICUSDT"];
        
        symbols.forEach(sym => {
          marketData[sym] = {
            marketCap: 1000000000 + Math.random() * 9000000000,
            totalVolume: 10000000 + Math.random() * 90000000,
            price: 100 + Math.random() * 1000,
            volumeMCapRatio: 0.5 + Math.random() * 4.5
          };
        });
      }
      
      symbols = [...new Set([...watchlist, ...symbols.slice(0, count)])];
      
      statusEl.textContent=`${symbols.length} Ù†Ù…Ø§Ø¯. Ø¯Ø± Ø­Ø§Ù„ Ø§Ø³Ú©Ù†...`;
      
      const out=[];
      let processed=0;
      
      const symbolsToScan = symbols.slice(0, 30);
      
      for(const sym of symbolsToScan){
        for(const tf of tfs){
          try{
            const bars = await fetchKlines(sym,tf);
            if(bars && bars.length > 50){
              const res = analyzeSymbolProTL(bars,pivLR,maLen,useMA, marketData);
              if(res){
                out.push({sym, tf, bars, analysis:res});
              }
            }
          }catch(e){
            console.log(`Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª ${sym} ${tf}:`, e.message);
          }
        }
        processed++;
        if(processed%5===0){
          statusEl.textContent=`Ø¯Ø± Ø­Ø§Ù„ Ø§Ø³Ú©Ù†: ${processed}/${symbolsToScan.length}`;
        }
      }
      
      // ÙÛŒÙ„ØªØ± Ù‡ÙˆØ´Ù…Ù†Ø¯
      let filteredResults = filterResults(out, marketData);
      
      // Ø§Ø¹Ù…Ø§Ù„ ÙÛŒÙ„ØªØ± Ù‡ÙˆØ´Ù…Ù†Ø¯ Ø§Ø¶Ø§ÙÛŒ
      if (filteredResults.length > 0) {
        filteredResults = smartFilter(filteredResults);
      }
      
      // Ù…Ø±ØªØ¨â€ŒØ³Ø§Ø²ÛŒ Ø¨Ø± Ø§Ø³Ø§Ø³ Ø§Ù…ØªÛŒØ§Ø² ØªØ±Ú©ÛŒØ¨ÛŒ
      filteredResults.sort((a, b) => b.analysis.combinedScore - a.analysis.combinedScore);
      
      statusEl.textContent=`Ù¾Ø§ÛŒØ§Ù† Ø§Ø³Ú©Ù†. ${filteredResults.length} Ø³ÛŒÚ¯Ù†Ø§Ù„ Ù¾ÛŒØ¯Ø§ Ø´Ø¯.`;
      scanBtn.disabled=false;
      scanBtn.textContent="ğŸ” Ø§Ø³Ú©Ù† Ø¯Ø³ØªÛŒ";
      
      const newSignals = [];
      const newKeySet = new Set();
      
      filteredResults.forEach((r,idx)=>{
        const a = r.analysis;
        const key = `${r.sym}_${r.tf}_${a.tlSignal||""}_${a.breakRes?"R":""}_${a.breakSup?"S":""}`;
        newKeySet.add(key);
        if(!lastSignalsKeySet.has(key)){
          newSignals.push(r);
        }
        
        const symbolName = r.sym.replace("USDT", "");
        const marketInfo = marketData[r.sym] || {volumeMCapRatio: 0, totalVolume: 0};
        const activeCount = a.activeStrategies;
        
        let candleDisplay = "-";
        let strengthDisplay = `<div class="strength-bar"><div class="strength-fill strength-medium" style="width:${a.candleStrength}%"></div></div>`;
        
        if(a.candlePattern){
          const candleClass = a.candlePattern.type === 'bullish' ? 'pattern-bull' : 'pattern-bear';
          candleDisplay = `<span class="candle-pattern ${candleClass}">${a.candlePattern.pattern}</span>`;
          const strengthClass = a.candleStrength >= 70 ? 'strength-high' : a.candleStrength >= 40 ? 'strength-medium' : 'strength-low';
          strengthDisplay = `<div class="strength-bar"><div class="strength-fill ${strengthClass}" style="width:${a.candleStrength}%"></div></div>`;
        }
        
        // Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø§Ø¶Ø§ÙÛŒ
        const extraInfo = a.extra || {};
        const extraDisplay = extraInfo.positionPercent ? 
          `<div class="extra-info">Ù…ÙˆÙ‚Ø¹ÛŒØª: ${extraInfo.positionPercent}% | Ù‚Ø¯Ø±Øª Ø±ÙˆÙ†Ø¯: ${extraInfo.trendStrength}%</div>` : '';
        
        const volumeMCapDisplay = marketInfo ? getVolumeMCapBadge(marketInfo.volumeMCapRatio) : "-";
        
        const tr=document.createElement("tr");
        tr.innerHTML=`
          <td>${idx+1}</td>
          <td><strong>${symbolName}</strong>${extraDisplay}</td>
          <td>${r.tf}</td>
          <td>${a.tlSignal ? `<span class="badge ${a.tlSignal==="BreakUp"?"up":"down"}">${a.tlSignal}</span>` : "-"}</td>
          <td>${a.breakRes ? `<span class="badge res">Res</span>` : a.breakSup ? `<span class="badge sup">Sup</span>` : "-"}</td>
          <td>${a.rangeAnalysis ? `<span class="badge range">${a.rangeAnalysis.type}</span>` : "-"}</td>
          <td>${a.ichimokuAnalysis ? `<span class="badge ichimoku">${a.ichimokuAnalysis.type}</span>` : "-"}</td>
          <td>${a.emaCrossAnalysis ? `<span class="badge ema-cross">${a.emaCrossAnalysis.type}</span>` : "-"}</td>
          <td>${volumeMCapDisplay}</td>
          <td>${candleDisplay}</td>
          <td><span class="combined-score">${a.combinedScore}<span class="strategy-count">${activeCount}</span></span></td>
          <td>${strengthDisplay}</td>
          <td>${a.lastRSI ? `<span style="color:${a.lastRSI>70?'#ef4444':a.lastRSI<30?'#22c55e':'#94a3b8'}">${a.lastRSI.toFixed(1)}</span>` : "-"}</td>
          <td>
            ${notesSystem.renderNoteCell(r.sym, r.tf)}
            <button class="action-btn share-btn" title="Ø§Ø´ØªØ±Ø§Ú©â€ŒÚ¯Ø°Ø§Ø±ÛŒ" onclick="shareSignal(${JSON.stringify(r).replace(/"/g, '&quot;')})">
              ğŸ“¤
            </button>
            <button class="action-btn backtest-btn" title="Ø¨Ú©ØªØ³Øª Ø³Ø±ÛŒØ¹" onclick="runQuickBacktest('${r.sym}', '${r.tf}')">
              ğŸ“ˆ
            </button>
          </td>
          <td><button class="btn-secondary" style="padding:4px 8px; font-size:11px;">ğŸ“Š</button></td>
        `;
        
        const btn = tr.querySelector(".btn-secondary");
        btn.addEventListener("click",()=>{
          chartTitle.textContent = `${r.sym} â€“ ${r.tf}`;
          const infoParts=[];
          if(a.tlSignal) infoParts.push(`TL: ${a.tlSignal}`);
          if(a.breakRes) infoParts.push("TD Res");
          if(a.breakSup) infoParts.push("TD Sup");
          if(a.rangeAnalysis) infoParts.push(`Range: ${a.rangeAnalysis.type}`);
          if(a.ichimokuAnalysis) infoParts.push(`Ichi: ${a.ichimokuAnalysis.type}`);
          if(a.emaCrossAnalysis) infoParts.push(`EMA: ${a.emaCrossAnalysis.type}`);
          if(a.candlePattern){
            infoParts.push(`${a.candlePattern.pattern}`);
          }
          infoParts.push(`Ø§Ù…ØªÛŒØ§Ø²: ${a.combinedScore}`);
          infoParts.push(`Ø§Ø³ØªØ±Ø§ØªÚ˜ÛŒâ€ŒÙ‡Ø§: ${a.activeStrategies}`);
          infoParts.push(`RSI: ${a.lastRSI.toFixed(1)}`);
          if(marketInfo) {
            infoParts.push(`Vol/MCap: ${marketInfo.volumeMCapRatio.toFixed(1)}%`);
          }
          if(a.extra){
            infoParts.push(`Ù…ÙˆÙ‚Ø¹ÛŒØª: ${a.extra.positionPercent}%`);
          }
          chartInfo.textContent = infoParts.join(" | ");
          chartContainer.style.display="block";
          chartViewState = {
            offset: 0,
            visibleBars: 100,
            zoom: 1.0
          };
          drawChart(r.bars, a, showIndicatorsSelect.value);
        });
        resultsBody.appendChild(tr);
      });
      
      if(newSignals.length>0){
        if(soundAlertCheckbox.checked) beep();
        if(Notification.permission==="granted"){
          new Notification(`Ø³ÛŒÚ¯Ù†Ø§Ù„ Ø¬Ø¯ÛŒØ¯: ${newSignals.length} Ù…ÙˆØ±Ø¯`,{
            body:"Ø§Ø³Ú©Ù†Ø± Ø³ÛŒÚ¯Ù†Ø§Ù„ Ø¬Ø¯ÛŒØ¯ Ù¾ÛŒØ¯Ø§ Ú©Ø±Ø¯.",
            silent: true
          });
        }
      }
      lastSignalsKeySet = newKeySet;
    }
    
    scanBtn.addEventListener("click",()=>scanOnce(true));
    
    autoScanCheckbox.addEventListener("change",()=>{
      if(autoScanCheckbox.checked){
        const sec = +autoScanInterval.value || 60;
        if(autoScanTimer) clearInterval(autoScanTimer);
        autoScanTimer = setInterval(()=>{
          if(!scanBtn.disabled) scanOnce(false);
        }, sec*1000);
        statusEl.textContent = `Auto-scan ÙØ¹Ø§Ù„ (Ù‡Ø± ${sec} Ø«Ø§Ù†ÛŒÙ‡)`;
      }else{
        if(autoScanTimer) clearInterval(autoScanTimer);
        autoScanTimer=null;
        statusEl.textContent="Ø¢Ù…Ø§Ø¯Ù‡";
      }
    });
    
    // ========== ÙˆÛŒÚ˜Ú¯ÛŒâ€ŒÙ‡Ø§ÛŒ Ø¬Ø¯ÛŒØ¯ ==========
    
    // Ø¯Ú©Ù…Ù‡â€ŒÙ‡Ø§ÛŒ Ù¾Ø±ÛŒØ³Øª
    document.querySelectorAll('.preset-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        applyPreset(btn.dataset.preset);
      });
    });
    
    // ========== Ú©Ù†ØªØ±Ù„ Ù†Ù…Ø§ÛŒØ´/Ù…Ø®ÙÛŒ ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø³Ø±ÛŒØ¹ ==========
    
    const toggleQuickSettingsBtn = document.getElementById('toggleQuickSettingsBtn');
    const quickSettings = document.getElementById('quickSettings');
    const reportBtn = document.getElementById('reportBtn');
    
    // ØªØ§Ø¨Ø¹ Ù†Ù…Ø§ÛŒØ´/Ù…Ø®ÙÛŒ Ú©Ø±Ø¯Ù† ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø³Ø±ÛŒØ¹
    function toggleQuickSettings() {
      quickSettingsVisible = !quickSettingsVisible;
      
      if (quickSettingsVisible) {
        quickSettings.classList.remove('hidden');
        reportBtn.classList.remove('hidden');
        toggleQuickSettingsBtn.innerHTML = 'âŒ';
        toggleQuickSettingsBtn.title = 'Ù…Ø®ÙÛŒ Ú©Ø±Ø¯Ù† ØªÙ†Ø¸ÛŒÙ…Ø§Øª';
      } else {
        quickSettings.classList.add('hidden');
        reportBtn.classList.add('hidden');
        toggleQuickSettingsBtn.innerHTML = 'âš™ï¸';
        toggleQuickSettingsBtn.title = 'Ù†Ù…Ø§ÛŒØ´ ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø³Ø±ÛŒØ¹';
      }
    }
    
    // Ø±ÙˆÛŒØ¯Ø§Ø¯ Ú©Ù„ÛŒÚ© Ø¨Ø±Ø§ÛŒ Ø¯Ú©Ù…Ù‡ Ù†Ù…Ø§ÛŒØ´/Ù…Ø®ÙÛŒ
    toggleQuickSettingsBtn.addEventListener('click', toggleQuickSettings);
    
    // Ù…Ø®ÙÛŒ Ú©Ø±Ø¯Ù† ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø¨Ø§ Ú©Ù„ÛŒÚ© Ø¯Ø± Ù‡Ø± Ø¬Ø§ÛŒ Ø¯ÛŒÚ¯Ø± (Ø¨Ù‡ Ø¬Ø² Ø±ÙˆÛŒ ØªÙ†Ø¸ÛŒÙ…Ø§Øª)
    document.addEventListener('click', function(e) {
      if (quickSettingsVisible && 
          !e.target.closest('#quickSettings') && 
          !e.target.closest('#toggleQuickSettingsBtn') &&
          !e.target.closest('#reportBtn')) {
        toggleQuickSettings();
      }
    });
    
    // ========== Ú©Ù†ØªØ±Ù„ ØªÙ… ØªØ§Ø±ÛŒÚ©/Ø±ÙˆØ´Ù† ==========
    
    function updateThemeButtons(isDark) {
      if (isDark) {
        document.getElementById('darkModeToggle').textContent = 'ğŸŒ™';
      } else {
        document.getElementById('darkModeToggle').textContent = 'â˜€ï¸';
      }
    }
    
    // Ø¯Ú©Ù…Ù‡ Ø§ØµÙ„ÛŒ ØªÙ… ØªØ§Ø±ÛŒÚ©
    document.getElementById('darkModeToggle').addEventListener('click', () => {
      const isDark = !document.body.classList.contains('dark-mode');
      if (isDark) {
        document.body.classList.remove('light-mode');
        document.body.classList.add('dark-mode');
        document.getElementById('darkModeToggle').textContent = 'ğŸŒ™';
        localStorage.setItem('darkMode', true);
        updateThemeButtons(true);
      } else {
        document.body.classList.remove('dark-mode');
        document.body.classList.add('light-mode');
        document.getElementById('darkModeToggle').textContent = 'â˜€ï¸';
        localStorage.setItem('darkMode', false);
        updateThemeButtons(false);
      }
    });
    
    // Ø³Ø§ÛŒØ± Ú©Ù†ØªØ±Ù„â€ŒÙ‡Ø§ÛŒ Ø³Ø±ÛŒØ¹
    document.getElementById('clearFiltersBtn').addEventListener('click', () => {
      document.querySelectorAll('.strategy-filters input[type="checkbox"]')
        .forEach(cb => cb.checked = true);
      document.querySelectorAll('.preset-btn').forEach(btn => btn.classList.remove('active'));
      statusEl.textContent = 'ÙÛŒÙ„ØªØ±Ù‡Ø§ Ø¨Ø§Ø²Ù†Ø´Ø§Ù†ÛŒ Ø´Ø¯Ù†Ø¯';
    });
    
    document.getElementById('exportBtn').addEventListener('click', () => {
      const results = Array.from(resultsBody.querySelectorAll('tr')).map(tr => {
        const cells = tr.querySelectorAll('td');
        return {
          symbol: cells[1]?.querySelector('strong')?.textContent || '',
          timeframe: cells[2]?.textContent || '',
          signal: cells[3]?.querySelector('.badge')?.textContent || '',
          score: cells[10]?.querySelector('.combined-score')?.textContent || ''
        };
      }).filter(r => r.symbol);
      
      if (results.length === 0) {
        alert('Ù‡ÛŒÚ† Ø¯Ø§Ø¯Ù‡â€ŒØ§ÛŒ Ø¨Ø±Ø§ÛŒ Ø®Ø±ÙˆØ¬ÛŒ ÙˆØ¬ÙˆØ¯ Ù†Ø¯Ø§Ø±Ø¯');
        return;
      }
      
      generateReport(results);
    });
    
    // Ø¯Ú©Ù…Ù‡ Ú©Ù†ØªØ±Ù„ ØµØ¯Ø§ Ø¯Ø± ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø³Ø±ÛŒØ¹
    document.getElementById('soundToggleBtn').addEventListener('click', () => {
      soundEnabled = !soundEnabled;
      document.getElementById('soundToggleBtn').textContent = soundEnabled ? 'ğŸ””' : 'ğŸ”•';
      localStorage.setItem('soundEnabled', soundEnabled);
    });
    
    // Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø°Ø®ÛŒØ±Ù‡ Ø´Ø¯Ù‡
    const savedDarkMode = localStorage.getItem('darkMode');
    if (savedDarkMode === 'false') {
      document.body.classList.remove('dark-mode');
      document.body.classList.add('light-mode');
      document.getElementById('darkModeToggle').textContent = 'â˜€ï¸';
      updateThemeButtons(false);
    } else {
      updateThemeButtons(true);
    }
    
    const savedSound = localStorage.getItem('soundEnabled');
    if (savedSound === 'false') {
      soundEnabled = false;
      document.getElementById('soundToggleBtn').textContent = 'ğŸ”•';
    }
    
    // Ú¯Ø²Ø§Ø±Ø´â€ŒÚ¯ÛŒØ±ÛŒ
    reportBtn.addEventListener('click', () => {
      const results = [];
      resultsBody.querySelectorAll('tr').forEach(tr => {
        const cells = tr.querySelectorAll('td');
        if (cells.length > 10) {
          results.push({
            sym: cells[1]?.querySelector('strong')?.textContent + 'USDT' || '',
            tf: cells[2]?.textContent || '',
            analysis: {
              combinedScore: parseInt(cells[10]?.querySelector('.combined-score')?.textContent) || 0
            }
          });
        }
      });
      
      if (results.length === 0) {
        alert('Ø§Ø¨ØªØ¯Ø§ Ø§Ø³Ú©Ù† Ú©Ù†ÛŒØ¯');
        return;
      }
      
      generateReport(results);
    });
    
    // Ù…ÙˆØ¯Ø§Ù„ ÛŒØ§Ø¯Ø¯Ø§Ø´Øªâ€ŒÙ‡Ø§
    document.getElementById('closeNotesBtn').addEventListener('click', () => {
      document.getElementById('notesModal').style.display = 'none';
    });
    
    document.getElementById('addNoteBtn').addEventListener('click', () => {
      const input = document.getElementById('newNoteInput');
      const content = input.value.trim();
      
      if (content) {
        notesSystem.addNote(currentSymbolForNotes, currentTfForNotes, content);
        input.value = '';
        openNotes(currentSymbolForNotes, currentTfForNotes);
      }
    });
    
    // Ø¨Ú©ØªØ³Øª Ø³Ø±ÛŒØ¹
    async function runQuickBacktest(symbol, tf) {
      statusEl.textContent = `Ø¯Ø± Ø­Ø§Ù„ Ø§Ø¬Ø±Ø§ÛŒ Ø¨Ú©ØªØ³Øª ${symbol} ${tf}...`;
      
      const result = await simpleBacktest(symbol, tf);
      
      if (result.success) {
        alert(`
Ù†ØªØ§ÛŒØ¬ Ø¨Ú©ØªØ³Øª ${symbol} ${tf}:
------------------------
ØªØ¹Ø¯Ø§Ø¯ Ù…Ø¹Ø§Ù…Ù„Ø§Øª: ${result.totalTrades}
Ù†Ø±Ø® Ø¨Ø±Ø¯: ${result.winRate}%
Ù…ÛŒØ§Ù†Ú¯ÛŒÙ† Ø³ÙˆØ¯: ${result.avgProfit}%
Ø¨Ù‡ØªØ±ÛŒÙ† Ù…Ø¹Ø§Ù…Ù„Ù‡: ${result.bestTrade}%
Ø¨Ø¯ØªØ±ÛŒÙ† Ù…Ø¹Ø§Ù…Ù„Ù‡: ${result.worstTrade}%
Ø³ÙˆØ¯ Ú©Ù„: ${result.totalProfit}%
        `);
      } else {
        alert(`Ø®Ø·Ø§ Ø¯Ø± Ø¨Ú©ØªØ³Øª: ${result.message}`);
      }
      
      statusEl.textContent = "Ø¢Ù…Ø§Ø¯Ù‡";
    }
    
    // Ø§Ø´ØªØ±Ø§Ú©â€ŒÚ¯Ø°Ø§Ø±ÛŒ (ØªØ§Ø¨Ø¹ Ú¯Ù„ÙˆØ¨Ø§Ù„)
    window.shareSignal = shareSignal;
    window.openNotes = openNotes;
    window.runQuickBacktest = runQuickBacktest;
    
    // ========== PWA ==========
    
    // Ù…Ø®ÙÛŒ Ú©Ø±Ø¯Ù† splash screen
    window.addEventListener('load', () => {
      setTimeout(() => {
        document.getElementById('splashScreen').style.opacity = '0';
        setTimeout(() => {
          document.getElementById('splashScreen').style.display = 'none';
        }, 300);
      }, 1000);
    });
    
    // Ù†ØµØ¨ PWA
    let deferredPrompt;
    const installBtn = document.getElementById('installBtn');
    
    window.addEventListener('beforeinstallprompt', (e) => {
      e.preventDefault();
      deferredPrompt = e;
      setTimeout(() => {
        installBtn.style.display = 'block';
      }, 3000);
      
      installBtn.addEventListener('click', async () => {
        installBtn.style.display = 'none';
        deferredPrompt.prompt();
        const { outcome } = await deferredPrompt.userChoice;
        deferredPrompt = null;
      });
    });
    
    window.addEventListener('appinstalled', () => {
      installBtn.style.display = 'none';
    });
    
    // ÙˆØ¶Ø¹ÛŒØª Ø¢Ù†Ù„Ø§ÛŒÙ†/Ø¢ÙÙ„Ø§ÛŒÙ†
    const offlineAlert = document.getElementById('offlineAlert');
    
    function updateOnlineStatus() {
      if (navigator.onLine) {
        offlineAlert.style.display = 'none';
      } else {
        offlineAlert.style.display = 'block';
      }
    }
    
    window.addEventListener('online', updateOnlineStatus);
    window.addEventListener('offline', updateOnlineStatus);
    updateOnlineStatus();
    
    resizeCanvas();
  </script>
</body>
</html>